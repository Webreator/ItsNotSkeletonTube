if (typeof Prototype == 'undefined') {
    throw 'Unable to load Shadowbox, Prototype framework not found.';
}
if (typeof Effect == 'undefined') {
    throw 'Unable to load Shadowbox, Scriptaculous effects framework not found.';
}
var Shadowbox = {};
Shadowbox.lib = {
    getStyle: function(el, style) {
        return Element.getStyle(el, style);
    },
    setStyle: function(el, style, value) {
        if (value == 'NaNpx') {
            return false;
        }
        if (typeof style != 'object') {
            var temp = {};
            temp[style] = value;
            style = temp;
        }
        Element.setStyle(el, style);
    },
    get: function(el) {
        return $(el);
    },
    remove: function(el) {
        Element.remove(el);
    },
    getTarget: function(e) {
        return Event.element(e);
    },
    preventDefault: function(e) {
        Event.stop(e);
    },
    addEvent: function(el, name, handler) {
        Event.observe(el, name, handler);
    },
    removeEvent: function(el, name, handler) {
        Event.stopObserving(el, name, handler);
    },
    animate: function(el, obj, duration, callback) {
        var o = {};
        for (var p in obj) {
            for (var p in obj) {
                o[p] = String(obj[p].to);
                if (p != 'opacity') o[p] += 'px';
            }
        }
        return new Effect.Morph(el, {
            afterFinish: callback,
            duration: duration,
            style: o
        });
    }
};
if (typeof Shadowbox == 'undefined') {}
(function() {
    var version = '1.0';
    var options = {
        assetURL: '',
        loadingImage: 'images/ajax-loader.gif',
        animate: true,
        animSequence: 'wh',
        flvPlayer: 'flvplayer.swf',
        overlayColor: '#000',
        overlayOpacity: 0.75,
        overlayBgImage: 'images/overlay-85.png',
        listenOverlay: true,
        autoplayMovies: true,
        showMovieControls: true,
        resizeDuration: 0.35,
        fadeDuration: 0.35,
        displayNav: true,
        continuous: false,
        displayCounter: true,
        counterType: 'default',
        viewportPadding: 20,
        handleLgImages: 'resize',
        initialHeight: 160,
        initialWidth: 320,
        enableKeys: true,
        keysClose: ['c', 'q', 27],
        keysNext: ['n', 39],
        keysPrev: ['p', 37],
        onOpen: null,
        onFinish: null,
        onChange: null,
        onClose: null,
        handleUnsupported: 'link',
        skipSetup: false,
        text: {
            cancel: 'Cancel',
            loading: 'loading',
            close: '<span class="shortcut">C</span>lose',
            next: '<span class="shortcut">N</span>ext',
            prev: '<span class="shortcut">P</span>revious',
            errors: {
                single: 'You must install the <a href="{0}">{1}</a> browser plugin to view this content.',
                shared: 'You must install both the <a href="{0}">{1}</a> and <a href="{2}">{3}</a> browser plugins to view this content.',
                either: 'You must install either the <a href="{0}">{1}</a> or the <a href="{2}">{3}</a> browser plugin to view this content.'
            }
        },
        errors: {
            fla: {
                name: 'Flash',
                url: 'http://www.adobe.com/products/flashplayer/'
            },
            qt: {
                name: 'QuickTime',
                url: 'http://www.apple.com/quicktime/download/'
            },
            wmp: {
                name: 'Windows Media Player',
                url: 'http://www.microsoft.com/windows/windowsmedia/'
            },
            f4m: {
                name: 'Flip4Mac',
                url: 'http://www.flip4mac.com/wmv_download.htm'
            }
        },
        skin: {
            main: '<div id="shadowbox_overlay"></div>' + '<div id="shadowbox_container">' + '<div id="shadowbox">' + '<div id="shadowbox_title">' + '<div id="shadowbox_title_inner"></div>' + '</div>' + '<div id="shadowbox_body">' + '<div id="shadowbox_body_inner"></div>' + '<div id="shadowbox_loading"></div>' + '</div>' + '<div id="shadowbox_toolbar">' + '<div id="shadowbox_toolbar_inner"></div>' + '</div>' + '</div>' + '</div>',
            loading: '<img src="{0}" alt="{1}" />' + '<span><a href="javascript:Shadowbox.close();">{2}</a></span>',
            counter: '<div id="shadowbox_counter">{0}</div>',
            close: '<div id="shadowbox_nav_close">' + '<a href="#" onclick="Shadowbox.close(); return false;" title="Close">x</a>' + '</div>',
            next: '<div id="shadowbox_nav_next">' + '<a href="javascript:Shadowbox.next();">{0}</a>' + '</div>',
            prev: '<div id="shadowbox_nav_previous">' + '<a href="javascript:Shadowbox.previous();">{0}</a>' + '</div>'
        },
        ext: {
            img: ['png', 'jpg', 'jpeg', 'gif', 'bmp'],
            qt: ['dv', 'mov', 'moov', 'movie', 'mp4'],
            wmp: ['asf', 'wm', 'wmv'],
            qtwmp: ['avi', 'mpg', 'mpeg'],
            iframe: ['asp', 'aspx', 'cgi', 'cfm', 'htm', 'html', 'pl', 'php', 'php3', 'php4', 'php5', 'phtml', 'rb', 'rhtml', 'shtml', 'txt', 'vbs']
        }
    };
    var default_options = null;
    var SL = Shadowbox.lib;
    var RE = {
        resize: /(img|swf|flv)/,
        overlay: /(img|iframe|html|inline)/,
        swf: /\.swf\s*$/i,
        flv: /\.flv\s*$/i,
        domain: /:\/\/(.*?)[:\/]/,
        inline: /#(.+)$/,
        rel: /^(light|shadow)box/i,
        gallery: /^(light|shadow)box\[(.*?)\]/i,
        unsupported: /^unsupported-(\w+)/,
        param: /\s*([a-z_]*?)\s*=\s*(.+)\s*/,
        empty: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i
    };
    var cache = [];
    var current_gallery;
    var current;
    var optimal_height = options.initialHeight;
    var optimal_width = options.initialWidth;
    var current_height = 0;
    var current_width = 0;
    var preloader;
    var initialized = false;
    var activated = false;
    var drag;
    var draggable;
    var overlay_img_needed;
    var ua = navigator.userAgent.toLowerCase();
    var isStrict = document.compatMode == 'CSS1Compat',
        isOpera = ua.indexOf("opera") > -1,
        isIE = ua.indexOf('msie') > -1,
        isIE7 = ua.indexOf('msie 7') > -1,
        isBorderBox = isIE && !isStrict,
        isSafari = (/webkit|khtml/).test(ua),
        isSafari3 = isSafari && !!(document.evaluate),
        isGecko = !isSafari && ua.indexOf('gecko') > -1,
        isWindows = (ua.indexOf('windows') != -1 || ua.indexOf('win32') != -1),
        isMac = (ua.indexOf('macintosh') != -1 || ua.indexOf('mac os x') != -1),
        isLinux = (ua.indexOf('linux') != -1);
    var absolute_pos = isIE && !isIE7;
    var plugins = null;
    if (navigator.plugins && navigator.plugins.length) {
        var detectPlugin = function(plugin_name) {
            var detected = false;
            for (var i = 0, len = navigator.plugins.length; i < len; ++i) {
                if (navigator.plugins[i].name.indexOf(plugin_name) > -1) {
                    detected = true;
                    break;
                }
            }
            return detected;
        };
        var f4m = detectPlugin('Flip4Mac');
        var plugins = {
            fla: detectPlugin('Shockwave Flash'),
            qt: detectPlugin('QuickTime'),
            wmp: !f4m && detectPlugin('Windows Media'),
            f4m: f4m
        };
    } else {
        var detectPlugin = function(plugin_name) {
            var detected = false;
            try {
                var axo = new ActiveXObject(plugin_name);
                if (axo) {
                    detected = true;
                }
            } catch (e) {}
            return detected;
        };
        var plugins = {
            fla: detectPlugin('ShockwaveFlash.ShockwaveFlash'),
            qt: detectPlugin('QuickTime.QuickTime'),
            wmp: detectPlugin('wmplayer.ocx'),
            f4m: false
        };
    }
    var apply = function(o, e) {
        for (var p in e) o[p] = e[p];
        return o;
    };
    var isLink = function(el) {
        return typeof el.tagName == 'string' && (el.tagName.toUpperCase() == 'A' || el.tagName.toUpperCase() == 'AREA');
    };
    SL.getViewportHeight = function() {
        var height = window.innerHeight;
        var mode = document.compatMode;
        if ((mode || isIE) && !isOpera) {
            height = isStrict ? document.documentElement.clientHeight : document.body.clientHeight;
        }
        return height;
    };
    SL.getViewportWidth = function() {
        var width = window.innerWidth;
        var mode = document.compatMode;
        if (mode || isIE) {
            width = isStrict ? document.documentElement.clientWidth : document.body.clientWidth;
        }
        return width;
    };
    SL.getDocumentHeight = function() {
        var scrollHeight = isStrict ? document.documentElement.scrollHeight : document.body.scrollHeight;
        return Math.max(scrollHeight, SL.getViewportHeight());
    };
    SL.getDocumentWidth = function() {
        var scrollWidth = isStrict ? document.documentElement.scrollWidth : document.body.scrollWidth;
        return Math.max(scrollWidth, SL.getViewportWidth());
    };
    var clearOpacity = function(el) {
        if (isIE) {
            if (typeof el.style.filter == 'string' && (/alpha/i).test(el.style.filter)) {
                el.style.filter = '';
            }
        } else {
            el.style.opacity = '';
            el.style['-moz-opacity'] = '';
            el.style['-khtml-opacity'] = '';
        }
    };
    var fadeIn = function(el, endingOpacity, duration, callback) {
        if (options.animate) {
            SL.setStyle(el, 'opacity', 0);
            el.style.visibility = 'visible';
            SL.animate(el, {
                opacity: {
                    to: endingOpacity
                }
            }, duration, function() {
                if (endingOpacity == 1) clearOpacity(el);
                if (typeof callback == 'function') callback();
            });
        } else {
            if (endingOpacity == 1) {
                clearOpacity(el);
            } else {
                SL.setStyle(el, 'opacity', endingOpacity);
            }
            el.style.visibility = 'visible';
            if (typeof callback == 'function') callback();
        }
    };
    var fadeOut = function(el, duration, callback) {
        var cb = function() {
            el.style.visibility = 'hidden';
            clearOpacity(el);
            if (typeof callback == 'function') callback();
        };
        if (options.animate) {
            SL.animate(el, {
                opacity: {
                    to: 0
                }
            }, duration, cb);
        } else {
            cb();
        }
    };
    var appendHTML = function(el, html) {
        el = SL.get(el);
        if (el.insertAdjacentHTML) {
            el.insertAdjacentHTML('BeforeEnd', html);
            return el.lastChild;
        }
        if (el.lastChild) {
            var range = el.ownerDocument.createRange();
            range.setStartAfter(el.lastChild);
            var frag = range.createContextualFragment(html);
            el.appendChild(frag);
            return el.lastChild;
        } else {
            el.innerHTML = html;
            return el.lastChild;
        }
    };
    var overwriteHTML = function(el, html) {
        el = SL.get(el);
        el.innerHTML = html;
        return el.firstChild;
    };
    var getComputedHeight = function(el) {
        var h = Math.max(el.offsetHeight, el.clientHeight);
        if (!h) {
            h = parseInt(SL.getStyle(el, 'height'), 10) || 0;
            if (!isBorderBox) {
                h += parseInt(SL.getStyle(el, 'padding-top'), 10) +
                    parseInt(SL.getStyle(el, 'padding-bottom'), 10) +
                    parseInt(SL.getStyle(el, 'border-top-width'), 10) +
                    parseInt(SL.getStyle(el, 'border-bottom-width'), 10);
            }
        }
        return h;
    };
    var getComputedWidth = function(el) {
        var w = Math.max(el.offsetWidth, el.clientWidth);
        if (!w) {
            w = parseInt(SL.getStyle(el, 'width'), 10) || 0;
            if (!isBorderBox) {
                w += parseInt(SL.getStyle(el, 'padding-left'), 10) +
                    parseInt(SL.getStyle(el, 'padding-right'), 10) +
                    parseInt(SL.getStyle(el, 'border-left-width'), 10) +
                    parseInt(SL.getStyle(el, 'border-right-width'), 10);
            }
        }
        return w;
    };
    var getPlayerType = function(url) {
        if (RE.img.test(url)) return 'img';
        var match = url.match(RE.domain);
        var this_domain = match ? document.domain == match[1] : false;
        if (url.indexOf('#') > -1 && this_domain) return 'inline';
        var q_index = url.indexOf('?');
        if (q_index > -1) url = url.substring(0, q_index);
        if (RE.swf.test(url)) return plugins.fla ? 'swf' : 'unsupported-swf';
        if (RE.flv.test(url)) return plugins.fla ? 'flv' : 'unsupported-flv';
        if (RE.qt.test(url)) return plugins.qt ? 'qt' : 'unsupported-qt';
        if (RE.wmp.test(url)) {
            if (plugins.wmp) {
                return 'wmp';
            } else if (plugins.f4m) {
                return 'qt';
            } else {
                return isMac ? (plugins.qt ? 'unsupported-f4m' : 'unsupported-qtf4m') : 'unsupported-wmp';
            }
        } else if (RE.qtwmp.test(url)) {
            if (plugins.qt) {
                return 'qt';
            } else if (plugins.wmp) {
                return 'wmp';
            } else {
                return isMac ? 'unsupported-qt' : 'unsupported-qtwmp';
            }
        } else if (!this_domain || RE.iframe.test(url)) {
            return 'iframe';
        }
        return 'iframe';
    };
    var handleClick = function(ev) {
        var link;
        if (isLink(this)) {
            link = this;
        } else {
            link = SL.getTarget(ev);
            while (!isLink(link) && link.parentNode) {
                link = link.parentNode;
            }
        }
        Shadowbox.open(link);
        if (current_gallery.length) SL.preventDefault(ev);
    };
    var setupGallery = function(obj) {
        var copy = apply({}, obj);
        if (!obj.gallery) {
            current_gallery = [copy];
            current = 0;
        } else {
            current_gallery = [];
            var index, ci;
            for (var i = 0, len = cache.length; i < len; ++i) {
                ci = cache[i];
                if (ci.gallery) {
                    if (ci.content == obj.content && ci.gallery == obj.gallery && ci.title == obj.title) {
                        index = current_gallery.length;
                    }
                    if (ci.gallery == obj.gallery) {
                        current_gallery.push(apply({}, ci));
                    }
                }
            }
            if (index == null) {
                current_gallery.unshift(copy);
                index = 0;
            }
            current = index;
        }
        var match, r;
        for (var i = 0, len = current_gallery.length; i < len; ++i) {
            r = false;
            if (current_gallery[i].type == 'unsupported') {
                r = true;
            } else if (match = RE.unsupported.exec(current_gallery[i].type)) {
                if (options.handleUnsupported == 'link') {
                    current_gallery[i].type = 'html';
                    var m;
                    switch (match[1]) {
                        case 'qtwmp':
                            m = String.format(options.text.errors.either, options.errors.qt.url, options.errors.qt.name, options.errors.wmp.url, options.errors.wmp.name);
                            break;
                        case 'qtf4m':
                            m = String.format(options.text.errors.shared, options.errors.qt.url, options.errors.qt.name, options.errors.f4m.url, options.errors.f4m.name);
                            break;
                        default:
                            if (match[1] == 'swf' || match[1] == 'flv') match[1] = 'fla';
                            m = String.format(options.text.errors.single, options.errors[match[1]].url, options.errors[match[1]].name);
                    }
                    current_gallery[i] = apply(current_gallery[i], {
                        height: 160,
                        width: 320,
                        content: '<div class="shadowbox_message">' + m + '</div>'
                    });
                } else {
                    r = true;
                }
            } else if (current_gallery[i].type == 'inline') {
                var match = RE.inline.exec(current_gallery[i].content);
                if (match) {
                    var el;
                    if (el = SL.get(match[1])) {
                        current_gallery[i].content = el.innerHTML;
                    } else {
                        throw 'No element found with id ' + match[1];
                    }
                } else {
                    throw 'No element id found for inline content';
                }
            }
            if (r) {
                current_gallery.splice(i, 1);
                if (i < current) --current;
                --i;
            }
        }
    };
    var buildBars = function() {
        var link = current_gallery[current];
        if (!link) return;
        var title_i = SL.get('shadowbox_title_inner');
        title_i.innerHTML = (link.title) ? link.title : '';
        var tool_i = SL.get('shadowbox_toolbar_inner');
        tool_i.innerHTML = '';
        if (options.displayNav) {
            title_i.innerHTML = String.format(options.skin.close, options.text.close) + title_i.innerHTML;
            if (current_gallery.length > 1) {
                if (options.continuous) {
                    appendHTML(tool_i, String.format(options.skin.next, options.text.next));
                    appendHTML(tool_i, String.format(options.skin.prev, options.text.prev));
                } else {
                    if ((current_gallery.length - 1) > current) {
                        appendHTML(tool_i, String.format(options.skin.next, options.text.next));
                    }
                    if (current > 0) {
                        appendHTML(tool_i, String.format(options.skin.prev, options.text.prev));
                    }
                }
            }
        }
        if (current_gallery.length > 1 && options.displayCounter) {
            var counter = '';
            if (options.counterType == 'skip') {
                for (var i = 0, len = current_gallery.length; i < len; ++i) {
                    counter += '<a href="javascript:Shadowbox.change(' + i + ');"';
                    if (i == current) {
                        counter += ' class="shadowbox_counter_current"';
                    }
                    counter += '>' + (i + 1) + '</a>';
                }
            } else {
                counter = (current + 1) + ' of ' + current_gallery.length;
            }
            appendHTML(tool_i, String.format(options.skin.counter, counter));
        }
    };
    var hideBars = function(callback) {
        var title_m = getComputedHeight(SL.get('shadowbox_title'));
        var tool_m = 0 - getComputedHeight(SL.get('shadowbox_toolbar'));
        var title_i = SL.get('shadowbox_title_inner');
        var tool_i = SL.get('shadowbox_toolbar_inner');
        if (options.animate && callback) {
            SL.animate(title_i, {
                marginTop: {
                    to: title_m
                }
            }, 0.2);
            SL.animate(tool_i, {
                marginTop: {
                    to: tool_m
                }
            }, 0.2, callback);
        } else {
            SL.setStyle(title_i, 'marginTop', title_m + 'px');
            SL.setStyle(tool_i, 'marginTop', tool_m + 'px');
        }
    };
    var showBars = function(callback) {
        var title_i = SL.get('shadowbox_title_inner');
        if (options.animate) {
            if (title_i.innerHTML != '') {
                SL.animate(title_i, {
                    marginTop: {
                        to: 0
                    }
                }, 0.35);
            }
            SL.animate(SL.get('shadowbox_toolbar_inner'), {
                marginTop: {
                    to: 0
                }
            }, 0.35, callback);
        } else {
            if (title_i.innerHTML != '') {
                SL.setStyle(title_i, 'margin-top', '0px');
            }
            SL.setStyle(SL.get('shadowbox_toolbar_inner'), 'margin-top', '0px');
            callback();
        }
    };
    var resetDrag = function() {
        drag = {
            x: 0,
            y: 0,
            start_x: null,
            start_y: null
        };
    };
    var toggleDrag = function(on) {
        if (on) {
            resetDrag();
            var styles = ['position:absolute', 'cursor:' + (isGecko ? '-moz-grab' : 'move')];
            styles.push(isIE ? 'background-color:#fff;filter:alpha(opacity=0)' : 'background-color:transparent');
            appendHTML('shadowbox_body_inner', '<div id="shadowbox_drag_layer" style="' + styles.join(';') + '"></div>');
            SL.addEvent(SL.get('shadowbox_drag_layer'), 'mousedown', listenDrag);
        } else {
            var d = SL.get('shadowbox_drag_layer');
            if (d) {
                SL.removeEvent(d, 'mousedown', listenDrag);
                SL.remove(d);
            }
        }
    };
    var listenDrag = function(ev) {
        drag.start_x = ev.clientX;
        drag.start_y = ev.clientY;
        draggable = SL.get('shadowbox_content');
        SL.addEvent(document, 'mousemove', positionDrag);
        SL.addEvent(document, 'mouseup', unlistenDrag);
        if (isGecko) SL.setStyle(SL.get('shadowbox_drag_layer'), 'cursor', '-moz-grabbing');
    };
    var unlistenDrag = function() {
        SL.removeEvent(document, 'mousemove', positionDrag);
        SL.removeEvent(document, 'mouseup', unlistenDrag);
        if (isGecko) SL.setStyle(SL.get('shadowbox_drag_layer'), 'cursor', '-moz-grab');
    };
    var positionDrag = function(ev) {
        var move_y = ev.clientY - drag.start_y;
        drag.start_y = drag.start_y + move_y;
        drag.y = Math.max(Math.min(0, drag.y + move_y), current_height - optimal_height);
        SL.setStyle(draggable, 'top', drag.y + 'px');
        var move_x = ev.clientX - drag.start_x;
        drag.start_x = drag.start_x + move_x;
        drag.x = Math.max(Math.min(0, drag.x + move_x), current_width - optimal_width);
        SL.setStyle(draggable, 'left', drag.x + 'px');
    };
    var loadContent = function() {
        var obj = current_gallery[current];
        if (!obj) return;
        buildBars();
        switch (obj.type) {
            case 'img':
                preloader = new Image();
                preloader.onload = function() {
                    var h = obj.height ? parseInt(obj.height, 10) : preloader.height;
                    var w = obj.width ? parseInt(obj.width, 10) : preloader.width;
                    resizeContent(h, w, function(dims) {
                        showBars(function() {
                            setContent({
                                tag: 'img',
                                height: dims.i_height,
                                width: dims.i_width,
                                src: obj.content,
                                style: 'position:absolute'
                            });
                            if (dims.enableDrag && options.handleLgImages == 'drag') {
                                toggleDrag(true);
                                SL.setStyle(SL.get('shadowbox_drag_layer'), {
                                    height: dims.i_height + 'px',
                                    width: dims.i_width + 'px'
                                });
                            }
                            finishContent();
                        });
                    });
                    preloader.onload = function() {};
                };
                preloader.src = obj.content;
                break;
            case 'swf':
            case 'flv':
            case 'qt':
            case 'wmp':
                var markup = Shadowbox.movieMarkup(obj);
                resizeContent(markup.height, markup.width, function() {
                    showBars(function() {
                        setContent(markup);
                        finishContent();
                    });
                });
                break;
            case 'iframe':
                var h = obj.height ? parseInt(obj.height, 10) : SL.getViewportHeight();
                var w = obj.width ? parseInt(obj.width, 10) : SL.getViewportWidth();
                var content = {
                    tag: 'iframe',
                    name: 'shadowbox_content',
                    height: '100%',
                    width: '100%',
                    frameborder: '0',
                    marginwidth: '0',
                    marginheight: '0',
                    scrolling: 'auto'
                };
                resizeContent(h, w, function(dims) {
                    showBars(function() {
                        setContent(content);
                        var win = (isIE) ? SL.get('shadowbox_content').contentWindow : window.frames['shadowbox_content'];
                        win.location = obj.content;
                        finishContent();
                    });
                });
                break;
            case 'html':
            case 'inline':
                var h = obj.height ? parseInt(obj.height, 10) : SL.getViewportHeight();
                var w = obj.width ? parseInt(obj.width, 10) : SL.getViewportWidth();
                var content = {
                    tag: 'div',
                    cls: 'html',
                    html: obj.content
                };
                resizeContent(h, w, function() {
                    showBars(function() {
                        setContent(content);
                        finishContent();
                    });
                });
                break;
            default:
                throw 'Shadowbox cannot open content of type ' + obj.type;
        }
        if (current_gallery.length > 0) {
            var next = current_gallery[current + 1];
            if (!next) {
                next = current_gallery[0];
            }
            if (next.type == 'img') {
                var preload_next = new Image();
                preload_next.src = next.href;
            }
            var prev = current_gallery[current - 1];
            if (!prev) {
                prev = current_gallery[current_gallery.length - 1];
            }
            if (prev.type == 'img') {
                var preload_prev = new Image();
                preload_prev.src = prev.href;
            }
        }
    };
    var setContent = function(obj) {
        var id = 'shadowbox_content';
        var content = SL.get(id);
        if (content) {
            switch (content.tagName.toUpperCase()) {
                case 'OBJECT':
                    var link = current_gallery[(obj ? current - 1 : current)];
                    if (link.type == 'wmp' && isIE) {
                        try {
                            shadowbox_content.controls.stop();
                            shadowbox_content.URL = 'non-existent.wmv';
                            window.shadowbox_content = function() {};
                        } catch (e) {}
                    } else if (link.type == 'qt' && isSafari) {
                        try {
                            document.shadowbox_content.Stop();
                        } catch (e) {}
                        content.innerHTML = '';
                    }
                    setTimeout(function() {
                        SL.remove(content);
                    }, 10);
                    break;
                case 'IFRAME':
                    SL.remove(content);
                    if (isGecko) delete window.frames[id];
                    break;
                default:
                    SL.remove(content);
            }
        }
        if (obj) {
            if (!obj.id) obj.id = id;
            return appendHTML('shadowbox_body_inner', Shadowbox.createHTML(obj));
        }
        return null;
    };
    var finishContent = function() {
        var obj = current_gallery[current];
        if (!obj) return;
        hideLoading(function() {
            listenKeyboard(true);
            if (options.onFinish && typeof options.onFinish == 'function') {
                options.onFinish(obj);
            }
        });
    };
    var resizeContent = function(height, width, callback) {
        optimal_height = height;
        optimal_width = width;
        var resizable = RE.resize.test(current_gallery[current].type);
        var dims = getDimensions(optimal_height, optimal_width, resizable);
        if (callback) {
            var cb = function() {
                callback(dims);
            };
            switch (options.animSequence) {
                case 'hw':
                    adjustHeight(dims.height, dims.top, true, function() {
                        adjustWidth(dims.width, true, cb);
                    });
                    break;
                case 'wh':
                    adjustWidth(dims.width, true, function() {
                        adjustHeight(dims.height, dims.top, true, cb);
                    });
                    break;
                default:
                    adjustWidth(dims.width, true);
                    adjustHeight(dims.height, dims.top, true, cb);
            }
        } else {
            adjustWidth(dims.width, false);
            adjustHeight(dims.height, dims.top, false);
            if (options.handleLgImages == 'resize' && resizable) {
                var content = SL.get('shadowbox_content');
                if (content) {
                    content.height = dims.i_height;
                    content.width = dims.i_width;
                }
            }
        }
    };
    var getDimensions = function(o_height, o_width, resizable) {
        if (typeof resizable == 'undefined') resizable = false;
        var height = o_height = parseInt(o_height);
        var width = o_width = parseInt(o_width);
        var shadowbox_b = SL.get('shadowbox_body');
        var view_height = SL.getViewportHeight();
        var extra_height = parseInt(SL.getStyle(shadowbox_b, 'border-top-width'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'border-bottom-width'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'margin-top'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'margin-bottom'), 10) +
            getComputedHeight(SL.get('shadowbox_title')) +
            getComputedHeight(SL.get('shadowbox_toolbar')) +
            (2 * options.viewportPadding);
        if ((height + extra_height) >= view_height) {
            height = view_height - extra_height;
        }
        var view_width = SL.getViewportWidth();
        var extra_body_width = parseInt(SL.getStyle(shadowbox_b, 'border-left-width'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'border-right-width'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'margin-left'), 10) +
            parseInt(SL.getStyle(shadowbox_b, 'margin-right'), 10);
        var extra_width = extra_body_width + (2 * options.viewportPadding);
        if ((width + extra_width) >= view_width) {
            width = view_width - extra_width;
        }
        var enableDrag = false;
        var i_height = o_height;
        var i_width = o_width;
        var handle = options.handleLgImages;
        if (resizable && (handle == 'resize' || handle == 'drag')) {
            var change_h = (o_height - height) / o_height;
            var change_w = (o_width - width) / o_width;
            if (handle == 'resize') {
                if (change_h > change_w) {
                    width = Math.round((o_width / o_height) * height);
                } else if (change_w > change_h) {
                    height = Math.round((o_height / o_width) * width);
                }
                i_width = width;
                i_height = height;
            } else {
                var link = current_gallery[current];
                if (link) enableDrag = link.type == 'img' && (change_h > 0 || change_w > 0);
            }
        }
        return {
            height: height,
            width: width + extra_body_width,
            i_height: i_height,
            i_width: i_width,
            top: ((view_height - (height + extra_height)) / 2) + options.viewportPadding,
            enableDrag: enableDrag
        };
    };
    var centerVertically = function() {
        var shadowbox = SL.get('shadowbox');
        var scroll = document.documentElement.scrollTop;
        var s_top = scroll + Math.round((SL.getViewportHeight() - (shadowbox.offsetHeight || 0)) / 2);
        SL.setStyle(shadowbox, 'top', s_top + 'px');
    };
    var adjustHeight = function(height, top, animate, callback) {
        height = parseInt(height);
        current_height = height;
        var sbi = SL.get('shadowbox_body_inner');
        if (animate && options.animate) {
            SL.animate(sbi, {
                height: {
                    to: height
                }
            }, options.resizeDuration, callback);
        } else {
            SL.setStyle(sbi, 'height', height + 'px');
            if (typeof callback == 'function') callback();
        }
        if (absolute_pos) {
            centerVertically();
            SL.addEvent(window, 'scroll', centerVertically);
            top += document.documentElement.scrollTop;
        }
        var shadowbox = SL.get('shadowbox');
        if (animate && options.animate) {
            SL.animate(shadowbox, {
                top: {
                    to: top
                }
            }, options.resizeDuration);
        } else {
            if (top + 'px' == 'NaNpx') {
                if (absolute_pos) {
                    var scroll = document.documentElement.scrollTop;
                    var top = scroll + Math.round((SL.getViewportHeight() - height) / 2);
                    if ((top + height) > document.documentElement.clientHeight) {
                        top = Math.round((((top + height) / 2) - (document.documentElement.clientHeight / 2)) / 2);
                    }
                } else {
                    top = Math.round(((document.documentElement.clientHeight / 2) - (height / 2)) / 2);
                }
            }
            SL.setStyle(shadowbox, 'top', top + 'px');
        }
    };
    var adjustWidth = function(width, animate, callback) {
        width = parseInt(width);
        current_width = width;
        var shadowbox = SL.get('shadowbox');
        if (animate && options.animate) {
            SL.animate(shadowbox, {
                width: {
                    to: width
                }
            }, options.resizeDuration, callback);
        } else {
            SL.setStyle(shadowbox, 'width', width + 'px');
            if (typeof callback == 'function') callback();
        }
    };
    var listenKeyboard = function(on) {
        if (!options.enableKeys) return;
        if (on) {
            document.onkeydown = handleKey;
        } else {
            document.onkeydown = '';
        }
    };
    var assertKey = function(valid, key, code) {
        return (valid.indexOf(key) != -1 || valid.indexOf(code) != -1);
    };
    var handleKey = function(e) {
        var code = e ? e.which : event.keyCode;
        var key = String.fromCharCode(code).toLowerCase();
        if (assertKey(options.keysClose, key, code)) {
            Shadowbox.close();
        } else if (assertKey(options.keysPrev, key, code)) {
            Shadowbox.previous();
        } else if (assertKey(options.keysNext, key, code)) {
            Shadowbox.next();
        }
    };
    var toggleTroubleElements = function(on) {
        var vis = (on ? 'visible' : 'hidden');
        var selects = document.getElementsByTagName('select');
        for (i = 0, len = selects.length; i < len; ++i) {
            selects[i].style.visibility = vis;
        }
        var objects = document.getElementsByTagName('object');
        for (i = 0, len = objects.length; i < len; ++i) {
            objects[i].style.visibility = vis;
        }
        var embeds = document.getElementsByTagName('embed');
        for (i = 0, len = embeds.length; i < len; ++i) {
            embeds[i].style.visibility = vis;
        }
    };
    var showLoading = function() {
        var loading = SL.get('shadowbox_loading');
        overwriteHTML(loading, String.format(options.skin.loading, options.assetURL + options.loadingImage, options.text.loading, options.text.cancel));
        loading.style.visibility = 'visible';
    };
    var hideLoading = function(callback) {
        var t = current_gallery[current].type;
        var anim = (t == 'img' || t == 'html');
        var loading = SL.get('shadowbox_loading');
        if (anim) {
            fadeOut(loading, 0.35, callback);
        } else {
            loading.style.visibility = 'hidden';
            callback();
        }
    };
    var resizeOverlay = function() {
        var overlay = SL.get('shadowbox_overlay');
        SL.setStyle(overlay, {
            height: '100%',
            width: '100%'
        });
        SL.setStyle(overlay, 'height', SL.getDocumentHeight() + 'px');
        if (!isSafari3) {
            SL.setStyle(overlay, 'width', SL.getDocumentWidth() + 'px');
        }
    };
    var checkOverlayImgNeeded = function() {
        if (!(isGecko && isMac)) return false;
        for (var i = 0, len = current_gallery.length; i < len; ++i) {
            if (!RE.overlay.exec(current_gallery[i].type)) return true;
        }
        return false;
    };
    var toggleOverlay = function(callback) {
        var overlay = SL.get('shadowbox_overlay');
        if (overlay_img_needed == null) {
            overlay_img_needed = checkOverlayImgNeeded();
        }
        if (callback) {
            resizeOverlay();
            if (overlay_img_needed) {
                SL.setStyle(overlay, {
                    visibility: 'visible',
                    backgroundColor: 'transparent',
                    backgroundImage: 'url(' + options.assetURL + options.overlayBgImage + ')',
                    backgroundRepeat: 'repeat',
                    opacity: 1
                });
                callback();
            } else {
                SL.setStyle(overlay, {
                    visibility: 'visible',
                    backgroundImage: 'none'
                });
                fadeIn(overlay, options.overlayOpacity, options.fadeDuration, callback);
            }
        } else {
            if (overlay_img_needed) {
                SL.setStyle(overlay, 'visibility', 'hidden');
            } else {
                fadeOut(overlay, options.fadeDuration);
            }
            overlay_img_needed = null;
        }
    };
    Shadowbox.init = function(opts) {
        if (initialized) return;
        options = apply(options, opts || {});
        appendHTML(document.body, options.skin.main);
        RE.img = new RegExp('\.(' + options.ext.img.join('|') + ')\s*$', 'i');
        RE.qt = new RegExp('\.(' + options.ext.qt.join('|') + ')\s*$', 'i');
        RE.wmp = new RegExp('\.(' + options.ext.wmp.join('|') + ')\s*$', 'i');
        RE.qtwmp = new RegExp('\.(' + options.ext.qtwmp.join('|') + ')\s*$', 'i');
        RE.iframe = new RegExp('\.(' + options.ext.iframe.join('|') + ')\s*$', 'i');
        var id = null;
        var resize = function() {
            clearInterval(id);
            id = null;
            resizeOverlay();
            resizeContent(optimal_height, optimal_width);
        };
        SL.addEvent(window, 'resize', function() {
            if (activated) {
                if (id) {
                    clearInterval(id);
                    id = null;
                }
                if (!id) id = setInterval(resize, 50);
            }
        });
        if (options.listenOverlay) {
            SL.addEvent(SL.get('shadowbox_overlay'), 'click', Shadowbox.close);
        }
        if (absolute_pos) {
            SL.setStyle(SL.get('shadowbox_container'), 'position', 'absolute');
            SL.setStyle('shadowbox_body', 'zoom', 1);
            SL.addEvent(SL.get('shadowbox_container'), 'click', function(e) {
                var target = SL.getTarget(e);
                if (target.id && target.id == 'shadowbox_container') Shadowbox.close();
            });
        }
        if (!options.skipSetup) Shadowbox.setup();
        initialized = true;
    };
    Shadowbox.setup = function(links, opts) {
        if (!links) {
            var links = [];
            var a = document.getElementsByTagName('a'),
                rel;
            for (var i = 0, len = a.length; i < len; ++i) {
                rel = a[i].getAttribute('rel');
                if (rel && RE.rel.test(rel)) links[links.length] = a[i];
            }
        } else if (!links.length) {
            links = [links];
        }
        var link;
        for (var i = 0, len = links.length; i < len; ++i) {
            link = links[i];
            if (typeof link.shadowboxCacheKey == 'undefined') {
                link.shadowboxCacheKey = cache.length;
                SL.addEvent(link, 'click', handleClick);
            }
            cache[link.shadowboxCacheKey] = this.buildCacheObj(link, opts);
        }
    };
    Shadowbox.buildCacheObj = function(link, opts) {
        var href = link.href;
        var hrefO = link.getAttribute('href');
        if (hrefO == '#' || hrefO.substr(hrefO.length - 1, 1) == '#') {
            href = link.getAttribute('alt');
            link.setAttribute('href', href);
        }
        var o = {
            el: link,
            title: link.getAttribute('title'),
            type: getPlayerType(href),
            options: apply({}, opts || {}),
            content: href
        };
        var opt, l_opts = ['title', 'type', 'height', 'width', 'gallery'];
        for (var i = 0, len = l_opts.length; i < len; ++i) {
            opt = l_opts[i];
            if (typeof o.options[opt] != 'undefined') {
                o[opt] = o.options[opt];
                delete o.options[opt];
            }
        }
        var rel = link.getAttribute('rel');
        if (rel) {
            var match = rel.match(RE.gallery);
            if (match) o.gallery = escape(match[2]);
            var params = rel.split(';');
            for (var i = 0, len = params.length; i < len; ++i) {
                match = params[i].match(RE.param);
                if (match) {
                    if (match[1] == 'options') {
                        eval('o.options = apply(o.options, ' + match[2] + ')');
                    } else {
                        o[match[1]] = match[2];
                    }
                }
            }
        }
        return o;
    };
    Shadowbox.applyOptions = function(opts) {
        if (opts) {
            default_options = apply({}, options);
            options = apply(options, opts);
        }
    };
    Shadowbox.revertOptions = function() {
        if (default_options) {
            options = default_options;
            default_options = null;
        }
    };
    Shadowbox.open = function(obj, opts) {
        if (activated) return;
        activated = true;
        if (isLink(obj)) {
            if (typeof obj.shadowboxCacheKey == 'undefined' || typeof cache[obj.shadowboxCacheKey] == 'undefined') {
                obj = this.buildCacheObj(obj, opts);
            } else {
                obj = cache[obj.shadowboxCacheKey];
            }
        }
        this.revertOptions();
        if (obj.options || opts) {
            this.applyOptions(apply(apply({}, obj.options || {}), opts || {}));
        }
        setupGallery(obj);
        if (current_gallery.length) {
            if (options.onOpen && typeof options.onOpen == 'function') {
                options.onOpen(obj);
            }
            SL.setStyle(SL.get('shadowbox'), 'display', 'block');
            toggleTroubleElements(false);
            var dims = getDimensions(options.initialHeight, options.initialWidth);
            adjustHeight(dims.height, dims.top);
            adjustWidth(dims.width);
            hideBars(false);
            toggleOverlay(function() {
                SL.setStyle(SL.get('shadowbox'), 'visibility', 'visible');
                showLoading();
                loadContent();
            });
        }
    };
    Shadowbox.change = function(num) {
        if (!current_gallery) return;
        if (!current_gallery[num]) {
            if (!options.continuous) {
                return;
            } else {
                num = (num < 0) ? (current_gallery.length - 1) : 0;
            }
        }
        current = num;
        toggleDrag(false);
        setContent(null);
        listenKeyboard(false);
        if (options.onChange && typeof options.onChange == 'function') {
            options.onChange(current_gallery[current]);
        }
        showLoading();
        hideBars(loadContent);
    };
    Shadowbox.next = function() {
        return this.change(current + 1);
    };
    Shadowbox.previous = function() {
        return this.change(current - 1);
    };
    Shadowbox.close = function() {
        if (!activated) return;
        if (boxConfirmMsg != undefined && boxConfirmMsg != '') {
            if (!confirm(boxConfirmMsg)) {
                return true;
            }
            boxConfirmMsg = '';
        }
        listenKeyboard(false);
        SL.setStyle(SL.get('shadowbox'), {
            display: 'none',
            visibility: 'hidden'
        });
        if (absolute_pos) SL.removeEvent(window, 'scroll', centerVertically);
        toggleDrag(false);
        setContent(null);
        if (preloader) {
            preloader.onload = function() {};
            preloader = null;
        }
        toggleOverlay(false);
        toggleTroubleElements(true);
        if (options.onClose && typeof options.onClose == 'function') {
            options.onClose(current_gallery[current]);
        }
        activated = false;
    };
    Shadowbox.clearCache = function() {
        for (var i = 0, len = cache.length; i < len; ++i) {
            if (cache[i].el) {
                SL.removeEvent(cache[i].el, 'click', handleClick);
                delete cache[i].shadowboxCacheKey;
            }
        }
        cache = [];
    };
    Shadowbox.movieMarkup = function(obj) {
        var h = obj.height ? parseInt(obj.height, 10) : 300;
        var w = obj.width ? parseInt(obj.width, 10) : 300;
        var autoplay = options.autoplayMovies;
        var controls = options.showMovieControls;
        if (obj.options) {
            if (obj.options.autoplayMovies != null) {
                autoplay = obj.options.autoplayMovies;
            }
            if (obj.options.showMovieControls != null) {
                controls = obj.options.showMovieControls;
            }
        }
        var markup = {
            tag: 'object',
            name: 'shadowbox_content'
        };
        switch (obj.type) {
            case 'swf':
                var dims = getDimensions(h, w, true);
                h = dims.height;
                w = dims.width;
                markup.type = 'application/x-shockwave-flash';
                markup.data = obj.content;
                markup.children = [{
                    tag: 'param',
                    name: 'movie',
                    value: obj.content
                }];
                break;
            case 'flv':
                autoplay = autoplay ? 'true' : 'false';
                var showicons = 'false';
                var a = h / w;
                if (controls) {
                    showicons = 'true';
                    h += 20;
                }
                var dims = getDimensions(h, h / a, true);
                h = dims.height;
                w = (h - (controls ? 20 : 0)) / a;
                var flashvars = ['file=' + obj.content, 'height=' + h, 'width=' + w, 'autostart=' + autoplay, 'displayheight=' + (h - (controls ? 20 : 0)), 'showicons=' + showicons, 'backcolor=0x000000&amp;frontcolor=0xCCCCCC&amp;lightcolor=0x557722'];
                markup.type = 'application/x-shockwave-flash';
                markup.data = options.assetURL + options.flvPlayer;
                markup.children = [{
                    tag: 'param',
                    name: 'movie',
                    value: options.assetURL + options.flvPlayer
                }, {
                    tag: 'param',
                    name: 'flashvars',
                    value: flashvars.join('&amp;')
                }, {
                    tag: 'param',
                    name: 'allowfullscreen',
                    value: 'true'
                }];
                break;
            case 'qt':
                autoplay = autoplay ? 'true' : 'false';
                if (controls) {
                    controls = 'true';
                    h += 16;
                } else {
                    controls = 'false';
                }
                markup.children = [{
                    tag: 'param',
                    name: 'src',
                    value: obj.content
                }, {
                    tag: 'param',
                    name: 'scale',
                    value: 'aspect'
                }, {
                    tag: 'param',
                    name: 'controller',
                    value: controls
                }, {
                    tag: 'param',
                    name: 'autoplay',
                    value: autoplay
                }];
                if (isIE) {
                    markup.classid = 'clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B';
                    markup.codebase = 'http://www.apple.com/qtactivex/qtplugin.cab#version=6,0,2,0';
                } else {
                    markup.type = 'video/quicktime';
                    markup.data = obj.content;
                }
                break;
            case 'wmp':
                autoplay = autoplay ? 1 : 0;
                markup.children = [{
                    tag: 'param',
                    name: 'autostart',
                    value: autoplay
                }];
                if (isIE) {
                    if (controls) {
                        controls = 'full';
                        h += 70;
                    } else {
                        controls = 'none';
                    }
                    markup.classid = 'clsid:6BF52A52-394A-11d3-B153-00C04F79FAA6';
                    markup.children[markup.children.length] = {
                        tag: 'param',
                        name: 'url',
                        value: obj.content
                    };
                    markup.children[markup.children.length] = {
                        tag: 'param',
                        name: 'uimode',
                        value: controls
                    };
                } else {
                    if (controls) {
                        controls = 1;
                        h += 45;
                    } else {
                        controls = 0;
                    }
                    markup.type = 'video/x-ms-wmv';
                    markup.data = obj.content;
                    markup.children[markup.children.length] = {
                        tag: 'param',
                        name: 'showcontrols',
                        value: controls
                    };
                }
                break;
        }
        markup.height = h;
        markup.width = w;
        return markup;
    };
    Shadowbox.createHTML = function(obj) {
        var html = '<' + obj.tag;
        for (var attr in obj) {
            if (attr == 'tag' || attr == 'html' || attr == 'children') continue;
            if (attr == 'cls') {
                html += ' class="' + obj['cls'] + '"';
            } else {
                html += ' ' + attr + '="' + obj[attr] + '"';
            }
        }
        if (RE.empty.test(obj.tag)) {
            html += '/>\n';
        } else {
            html += '>\n';
            var cn = obj.children;
            if (cn) {
                for (var i = 0, len = cn.length; i < len; ++i) {
                    html += this.createHTML(cn[i]);
                }
            }
            if (obj.html) html += obj.html;
            html += '</' + obj.tag + '>\n';
        }
        return html;
    };
    Shadowbox.getPlugins = function() {
        return plugins;
    };
    Shadowbox.getOptions = function() {
        return options;
    };
    Shadowbox.getCurrent = function() {
        return current_gallery[current];
    };
    Shadowbox.getVersion = function() {
        return version;
    };
})();
Array.prototype.indexOf = Array.prototype.indexOf || function(o) {
    for (var i = 0, len = this.length; i < len; ++i) {
        if (this[i] == o) return i;
    }
    return -1;
};
String.format = String.format || function(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function(m, i) {
        return args[i];
    });
};
var Resizables = {
    resizers: [],
    observers: [],
    register: function(resizable) {
        if (this.resizers.length == 0) {
            this.eventMouseUp = this.endResize.bindAsEventListener(this);
            this.eventMouseMove = this.updateResize.bindAsEventListener(this);
            this.eventKeypress = this.keyPress.bindAsEventListener(this);
            Event.observe(document, "mouseup", this.eventMouseUp);
            Event.observe(document, "mousemove", this.eventMouseMove);
            Event.observe(document, "keypress", this.eventKeypress);
        }
        this.resizers.push(resizable);
    },
    unregister: function(resizable) {
        this.resizers = this.resizers.reject(function(r) {
            return r == resizable
        });
        if (this.resizers.length == 0) {
            Event.stopObserving(document, "mouseup", this.eventMouseUp);
            Event.stopObserving(document, "mousemove", this.eventMouseMove);
            Event.stopObserving(document, "keypress", this.eventKeypress);
        }
    },
    activate: function(resizable) {
        if (resizable.options.delay) {
            this._timeout = setTimeout(function() {
                Resizables._timeout = null;
                window.focus();
                Resizables.activeResizable = resizable;
            }.bind(this), resizable.options.delay);
        } else {
            window.focus();
            this.activeResizable = resizable;
        }
    },
    deactivate: function() {
        this.activeResizable = null;
    },
    updateResize: function(event) {
        if (!this.activeResizable) return;
        var pointer = [Event.pointerX(event), Event.pointerY(event)];
        if (this._lastPointer && (this._lastPointer.inspect() == pointer.inspect())) return;
        this._lastPointer = pointer;
        this.activeResizable.updateResize(event, pointer);
    },
    endResize: function(event) {
        if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = null;
        }
        if (!this.activeResizable) return;
        this._lastPointer = null;
        this.activeResizable.endResize(event);
        this.activeResizable = null;
    },
    keyPress: function(event) {
        if (this.activeResizable)
            this.activeResizable.keyPress(event);
    },
    addObserver: function(observer) {
        this.observers.push(observer);
        this._cacheObserverCallbacks();
    },
    removeObserver: function(element) {
        this.observers = this.observers.reject(function(o) {
            return o.element == element
        });
        this._cacheObserverCallbacks();
    },
    notify: function(eventName, resizable, event) {
        if (this[eventName + 'Count'] > 0)
            this.observers.each(function(o) {
                if (o[eventName]) o[eventName](eventName, resizable, event);
            });
        if (resizable.options[eventName]) resizable.options[eventName](resizable, event);
    },
    _cacheObserverCallbacks: function() {
        ['onStart', 'onEnd', 'onResize'].each(function(eventName) {
            Resizables[eventName + 'Count'] = Resizables.observers.select(function(o) {
                return o[eventName];
            }).length;
        });
    }
}
var Resizable = Class.create();
Resizable._resizing = {};
Resizable.prototype = {
    initialize: function(element) {
        var defaults = {
            handle: false,
            endeffect: function(element) {
                var toOpacity = typeof element._opacity == 'number' ? element._opacity : 1.0;
                new Effect.Opacity(element, {
                    duration: 0.2,
                    from: 0.7,
                    to: toOpacity,
                    queue: {
                        scope: '_resizable',
                        position: 'end'
                    },
                    afterFinish: function() {
                        Resizable._resizing[element] = false
                    }
                });
            },
            zindex: 1000,
            revert: false,
            snap: false,
            delay: 0
        };
        if (!arguments[1] || typeof arguments[1].endeffect == 'undefined')
            Object.extend(defaults, {
                starteffect: function(element) {
                    element._opacity = Element.getOpacity(element);
                    Resizable._resizing[element] = true;
                    new Effect.Opacity(element, {
                        duration: 0.2,
                        from: element._opacity,
                        to: 0.7
                    });
                }
            });
        var options = Object.extend(defaults, arguments[1] || {});
        this.element = $(element);
        if (options.handle && (typeof options.handle == 'string'))
            this.handle = this.element.down('.' + options.handle, 0);
        if (!this.handle) this.handle = $(options.handle);
        if (!this.handle) this.handle = this.element;
        Element.makePositioned(this.element);
        this.delta = this.currentDelta();
        this.options = options;
        this.resizing = false;
        this.eventMouseDown = this.initResize.bindAsEventListener(this);
        Event.observe(this.handle, "mousedown", this.eventMouseDown);
        Resizables.register(this);
    },
    reverteffect: function(element, horizontal, vertical) {
        var horiz = this._edim[0] - horizontal;
        var vert = this._edim[1] - vertical;
        new Effect.ReSize(element, {
            direction: 'vert',
            amount: vert
        });
        new Effect.ReSize(element, {
            direction: 'horizontal',
            amount: horiz
        });
    },
    destroy: function() {
        Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
        Resizables.unregister(this);
    },
    currentDelta: function() {
        return ([parseInt(Element.getStyle(this.element, 'left') || '0'), parseInt(Element.getStyle(this.element, 'top') || '0')]);
    },
    initResize: function(event) {
        if (typeof Resizable._resizing[this.element] != 'undefined' && Resizable._resizing[this.element]) return;
        if (Event.isLeftClick(event)) {
            var src = Event.element(event);
            if ((tag_name = src.tagName.toUpperCase()) && (tag_name == 'INPUT' || tag_name == 'SELECT' || tag_name == 'OPTION' || tag_name == 'BUTTON' || tag_name == 'TEXTAREA')) return;
            var pointer = [Event.pointerX(event), Event.pointerY(event)];
            this._initialX = pointer[0];
            this._initialY = pointer[1];
            var dim = Element.getDimensions(this.element);
            this._edim = [dim.width, dim.height];
            this._min = [1, 1];
            this._max = [0, 0];
            var pos = Position.cumulativeOffset(this.element);
            this.offset = [0, 1].map(function(i) {
                return (pointer[i] - pos[i])
            });
            if (this.options.bind == true) {
                this._parentDim = Element.getDimensions(this.element.parentNode);
                var cop = Position.cumulativeOffset(this.element.parentNode);
                var coe = Position.cumulativeOffset(this.element);
                this.elementOffset = [coe[0] - cop[0], coe[1] - cop[1]];
            }
            if (this.options.min) {
                if (this.options.min instanceof Array) {
                    this._min = this._min.map(function(v, i) {
                        return (this.options.min[i] > 0 ? this.options.min[i] : 1);
                    }.bind(this));
                } else
                    this._min = this._min.map(function(v, i) {
                        return (this.options.min > 0 ? this.options.min : 1);
                    }.bind(this));
            }
            if (this.options.max) {
                if (this.options.max instanceof Array) {
                    this._max = this._max.map(function(v, i) {
                        return (this.options.max[i] >= this._min[i]) ? this.options.max[i] : 0;
                    }.bind(this));
                } else
                    this._max = this._max.map(function(v, i) {
                        return (this.options.max >= this._min[i]) ? this.options.max : 0;
                    }.bind(this));
            }
            Resizables.activate(this);
            Event.stop(event);
        }
    },
    startResize: function(event) {
        this.resizing = true;
        if (this.options.zindex) {
            this.originalZ = parseInt(Element.getStyle(this.element, 'z-index') || 0);
            this.element.style.zIndex = this.options.zindex;
        }
        if (this.options.ghosting) {
            this._clone = this.element.cloneNode(true);
            this.element.parentNode.insertBefore(this._clone, this.element);
            var style = this._clone.style;
            Position.absolutize(this._clone);
            if (navigator.appName.indexOf('Microsoft') != -1 && parseInt(Element.getStyle(this.element, 'margin-top')) > 0) {
                this.element.style.top = style.marginTop;
            }
            style.margin = '0px';
        }
        Resizables.notify('onStart', this, event);
        if (this.options.starteffect) this.options.starteffect(this.element);
    },
    updateResize: function(event, pointer) {
        if (!this.resizing) this.startResize(event);
        Resizables.notify('onResize', this, event);
        this.draw(pointer);
        if (this.options.change) this.options.change(this);
        Event.stop(event);
    },
    finishResize: function(event, success) {
        this.resizing = false;
        if (this.options.ghosting) {
            if (navigator.appName.indexOf('Microsoft') != -1 && parseInt(Element.getStyle(this.element, 'margin-top')) > 0)
                this.element.style.top = this._clone.style.marginTop;
            Element.remove(this._clone);
            this._clone = null;
        }
        Resizables.notify('onEnd', this, event);
        var revert = this.options.revert;
        if (revert && typeof revert == 'function') revert = revert(this.element);
        if (revert && this.reverteffect) {
            var dim = Element.getDimensions(this.element);
            this.reverteffect(this.element, dim.width, dim.height);
        }
        if (this.options.zindex)
            this.element.style.zIndex = this.originalZ;
        if (this.options.endeffect)
            this.options.endeffect(this.element);
        Resizables.deactivate(this);
    },
    keyPress: function(event) {
        if (event.keyCode != Event.KEY_ESC) return;
        this.finishResize(event, false);
        Event.stop(event);
    },
    endResize: function(event) {
        if (!this.resizing) return;
        this.finishResize(event, true);
        Event.stop(event);
    },
    draw: function(point) {
        var pos = Position.cumulativeOffset(this.element);
        var d = this.currentDelta();
        pos[0] -= d[0];
        pos[1] -= d[1];
        var p = [0, 1].map(function(i) {
            return (point[i] - pos[i] - this.offset[i])
        }.bind(this));
        var l_width = p[0] + this._edim[0] - d[0];
        var l_height = p[1] + this._edim[1] - d[1];
        p[0] = (l_width > this._min[0]) ? l_width : this._min[0];
        p[1] = (l_height > this._min[1]) ? l_height : this._min[1];
        if (this.options.snap) {
            if (typeof this.options.snap == 'function') {
                p = this.options.snap(p[0], p[1], this);
            } else {
                if (this.options.snap instanceof Array) {
                    p = p.map(function(v, i) {
                        var dim = Math.round(v / this.options.snap[i]) * this.options.snap[i];
                        return (this.options.snap[i] > 0) ? ((dim > this._min[i]) ? dim : this._min[i]) : this._edim[i];
                    }.bind(this))
                } else {
                    p = p.map(function(v, i) {
                        var dim = Math.round(v / this.options.snap) * this.options.snap - d[i];
                        return (this.options.snap > 0) ? ((dim > this._min[i]) ? dim : this._min[i]) : this._edim[i]
                    }.bind(this))
                }
            }
        }
        if (this.options.bind) {
            if (this._parentDim.width <= p[0] + this.elementOffset[0])
                p[0] = this._parentDim.width - this.elementOffset[0] - 2;
            if (this._parentDim.height <= p[1] + this.elementOffset[1])
                p[1] = this._parentDim.height - this.elementOffset[1] - 2;
        }
        if (this.options.min) {
            p[0] = p[0] > this._min[0] ? p[0] : this._min[0];
            p[1] = p[1] > this._min[1] ? p[1] : this._min[1];
        }
        if (this.options.max) {
            p[0] = p[0] < this._max[0] ? p[0] : (this._max[0] > 0 ? this._max[0] : p[0]);
            p[1] = p[1] < this._max[1] ? p[1] : (this._max[1] > 0 ? this._max[1] : p[1]);
        }
        var style = this.element.style;
        if ((!this.options.constraint) || (this.options.constraint == 'horizontal'))
            style.width = p[0] + "px";
        if ((!this.options.constraint) || (this.options.constraint == 'vertical'))
            style.height = p[1] + "px";
        if (style.visibility == "hidden") style.visibility = "";
    }
}
Effect.ReSize = Class.create();
Object.extend(Object.extend(Effect.ReSize.prototype, Effect.Base.prototype), {
    initialize: function(element) {
        this.element = element;
        if (!this.element) throw (Effect._elementDoesNotExistError);
        var options = Object.extend({
            amount: 100,
            direction: 'vert',
            toSize: null
        }, arguments[1] || {});
        if (options.direction == 'vert')
            this.originalSize = options.originalSize || parseInt(this.element.style.height);
        else
            this.originalSize = options.originalSize || parseInt(this.element.style.width);
        if (options.toSize != null)
            options.amount = options.toSize - this.originalSize;
        this.start(options);
    },
    setup: function() {
        if (this.element.getStyle('display') == 'none') {
            this.cancel();
            return;
        }
    },
    update: function(position) {
        if (this.options.direction == 'vert') {
            this.element.setStyle({
                height: this.originalSize + (this.options.amount * position) + 'px'
            });
        } else {
            this.element.setStyle({
                width: this.originalSize + (this.options.amount * position) + 'px'
            });
        }
    },
    finish: function() {
        if (this.options.direction == 'vert') {
            this.element.setStyle({
                height: this.originalSize + this.options.amount + 'px'
            });
        } else {
            this.element.setStyle({
                width: this.originalSize + this.options.amount + 'px'
            });
        }
    }
});
var actLeft = 0;
var numItems = 21;
var visItemCount = 7;
var scrollStep = 92;
var scrollRightCount = 0;
var stopScroll = false;

function itemScrollRight(id, firstScroll) {
    if (firstScroll) {
        stopScroll = false;
    }
    if (stopScroll) {
        return;
    }
    if (scrollRightCount < (numItems - visItemCount)) {
        actLeft = actLeft - scrollStep;
        scrollRightCount = scrollRightCount + 1;
    } else {
        itemStopScroll();
    }
    document.getElementById(id).style.left = actLeft + 'px';
    if (firstScroll) {
        window.setTimeout("itemScrollRight('" + id + "', false)", 500);
    } else {
        window.setTimeout("itemScrollRight('" + id + "', false)", 100);
    }
}

function itemScrollLeft(id, firstScroll) {
    if (firstScroll) {
        stopScroll = false;
    }
    if (stopScroll) {
        return;
    }
    if (scrollRightCount > 0) {
        actLeft = actLeft + scrollStep;
        scrollRightCount = scrollRightCount - 1;
    } else {
        itemStopScroll();
    }
    document.getElementById(id).style.left = actLeft + 'px';
    if (firstScroll) {
        window.setTimeout("itemScrollLeft('" + id + "', false)", 500);
    } else {
        window.setTimeout("itemScrollLeft('" + id + "', false)", 100);
    }
}

function itemStopScroll() {
    stopScroll = true;
}

function ajaxRequest(url) {
    var xmlHttp = null;
    try {
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        try {
            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {
            try {
                xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e) {
                xmlHttp = null;
            }
        }
    }
    if (xmlHttp) {
        xmlHttp.open('GET', url, true);
        xmlHttp.onreadystatechange = function() {
            if (xmlHttp.readyState == 4) {
                return true;
            }
        };
        xmlHttp.send(null);
    }
    return false;
}

function shrinkAdminMenu() {
    document.getElementById('admin_menu').style.display = 'none';
    document.getElementById('admin_menu_small').style.display = 'block';
    document.getElementById('main_container').style.paddingTop = '0';
    return ajaxRequest('/admin/ajax_toggle_menu.do?toggle=shrink');
}

function expandAdminMenu() {
    document.getElementById('admin_menu').style.display = 'block';
    document.getElementById('admin_menu_small').style.display = 'none';
    document.getElementById('main_container').style.paddingTop = '87px';
    return ajaxRequest('/admin/ajax_toggle_menu.do?toggle=expand');
}

function am_showDropDown(id) {
    var elem = document.getElementById(id);
    if (!elem) {
        return false;
    }
    if (elem.style.display == 'block') {
        elem.style.display = 'none';
    } else {
        elem.style.display = 'block';
    }
    return true;
}

function am_hideDropDowns() {
    document.getElementById('dropdown_view').style.display = 'none';
}
var myAccountActive = false;

function sendPing() {
    var Jetzt = new Date();
    if ($('shadowbox_overlay') && $('shadowbox_overlay').style.visibility == 'visible') {
        new Ajax.Request('/ping.dox?nmc=1', {
            method: 'get'
        });
    } else {
        new Ajax.Request('/ping.dox', {
            method: 'get',
            onSuccess: function(msg) {
                processPong(msg.responseText);
            }
        });
    }
    window.setTimeout("sendPing()", 301000);
}

function initPing() {
    window.setTimeout("sendPing()", 301000);
}

function processPong(msg) {
    if (msg == '') {
        return false;
    }
    var parts = msg.split(":");
    if (parts[0] == 'im') {
        showBox('/popups/chat.html?user_id=' + parts[1], 600, 470, 'Neue Nachricht!');
        return true;
    } else if (parts[0] == 'pc') {
        showPrivChatRequest(parts[1]);
        return true;
    }
}

function setMyAccountActive() {
    myAccountActive = true;
}

function setMyAccountInactive() {
    myAccountActive = false;
}

function toggleMyAccount() {
    if (document.getElementById('divAccount').style.display == 'block') {
        document.getElementById('divAccount').style.display = 'none';
    } else {
        document.getElementById('divAccount').style.display = 'block';
    }
}

function hideMyAccount() {
    if (!myAccountActive) {
        document.getElementById('divAccount').style.display = 'none';
    }
}

function popupWriteIM(user_id_to, sid) {
    var width = 350;
    var height = 370;
    var left = (screen.width - width) / 2;
    var top = (screen.height - height) / 2;
    if (sid != '') {
        var sid_str = '&amp;' + sid;
    } else {
        var sid_str = '';
    }
    imPopup = window.open('/beta/popups/write_im.html?user_id_to=' + user_id_to + sid_str, "popupWriteIM", "width=" + width + ",height=" + height + ",left=" + left + ",top=" + top + ",menubar=no,location=no,resizable=yes,scrollbars=yes,toolbar=no,dependent=yes");
    imPopup.focus();
}

function popupEditSidebarModule(module, module_id) {
    var width = 350;
    var height = 450;
    var left = (screen.width - width) / 2;
    var top = (screen.height - height) / 2;
    editPopup = window.open('popups/edit_' + module + '.html?module_id=' + module_id, "popupWriteIM", "width=" + width + ",height=" + height + ",left=" + left + ",top=" + top + ",menubar=no,location=no,resizable=yes,scrollbars=yes,toolbar=no,dependent=yes");
    editPopup.focus();
}

function popupHelpVideo(url, width, height) {
    var left = (screen.width - width) / 2;
    var top = (screen.height - height) / 2;
    editPopup = window.open(url, "popupHelpVideo", "innerWidth=" + width + ",innerHeight=" + height + ",left=" + left + ",top=" + top + ",menubar=no,location=no,resizable=yes,scrollbars=no,toolbar=no,dependent=no");
    editPopup.focus();
}

function popupWindow(url, width, height, name, resize) {
    var left = (screen.width - width) / 2;
    var top = (screen.height - height) / 2;
    if (name == '') {
        name = 'popupWindow';
    }
    if (resize == '') {
        resize = 'yes';
    }
    editPopup = window.open(url, name, "width=" + width + ",height=" + height + ",left=" + left + ",top=" + top + ",menubar=no,location=no,resizable=" + resize + ",scrollbars=no,toolbar=no,dependent=no");
    editPopup.focus();
}

function textCounter(field, countfield, maxlimit) {
    if (field.value.length > maxlimit)
        field.value = field.value.substring(0, maxlimit);
    else
        countfield.value = maxlimit - field.value.length;
}

function htmlspecialchars(str, typ) {
    if (typeof str == "undefined") str = "";
    if (typeof typ != "number") typ = 2;
    typ = Math.max(0, Math.min(3, parseInt(typ)));
    var from = new Array(/&/g, /</g, />/g);
    var to = new Array("&amp;", "&lt;", "&gt;");
    if (typ == 1 || typ == 3) {
        from.push(/'/g);
        to.push("&#039;");
    }
    if (typ == 2 || typ == 3) {
        from.push(/"/g);
        to.push("&quot;");
    }
    for (var i in from) str = str.replace(from[i], to[i]);
    return str;
}

function showBox(url, boxWidth, boxHeight, title, isModal) {
    Shadowbox.open({
        content: url,
        title: title,
        type: 'iframe',
        height: boxHeight,
        width: boxWidth,
        listenOverlay: !isModal
    });
}

function showImgBox(url, title) {
    Shadowbox.open({
        content: url,
        title: title,
        type: 'img'
    });
}

function showPrivChatRequest(uid, title) {
    showBox('/popups/privchat_request.html?user_id=' + uid, 360, 125, title);
}

function openPrivChat(uid, sendRequest) {
    if (sendRequest) {
        var url = '/popups/privchat.html?user_id=' + uid + '&request=1';
    } else {
        var url = '/popups/privchat.html?user_id=' + uid;
    }
    popupWindow(url, 420, 500, 'privchat_' + uid, 'no');
}
var JSON = JSON || {};
(function() {
    function f(n) {
        return n < 10 ? '0' + n : n;
    }
    if (typeof Date.prototype.toJSON !== 'function') {
        Date.prototype.toJSON = function(key) {
            return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate()) + 'T' +
                f(this.getUTCHours()) + ':' +
                f(this.getUTCMinutes()) + ':' +
                f(this.getUTCSeconds()) + 'Z' : null;
        };
        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function(key) {
            return this.valueOf();
        };
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap, indent, meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        },
        rep;

    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }

    function str(key, holder) {
        var i, k, v, length, mind = gap,
            partial, value = holder[key];
        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch (typeof value) {
            case 'string':
                return quote(value);
            case 'number':
                return isFinite(value) ? String(value) : 'null';
            case 'boolean':
            case 'null':
                return String(value);
            case 'object':
                if (!value) {
                    return 'null';
                }
                gap += indent;
                partial = [];
                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap +
                        partial.join(',\n' + gap) + '\n' +
                        mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }
                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        k = rep[i];
                        if (typeof k === 'string') {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }
                v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                    mind + '}' : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }
    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function(value, replacer, space) {
            var i;
            gap = '';
            indent = '';
            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            } else if (typeof space === 'string') {
                indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
            return str('', {
                '': value
            });
        };
    }
    if (typeof JSON.parse !== 'function') {
        JSON.parse = function(text, reviver) {
            var j;

            function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function(a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }
            if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                j = eval('(' + text + ')');
                return typeof reviver === 'function' ? walk({
                    '': j
                }, '') : j;
            }
            throw new SyntaxError('JSON.parse');
        };
    }
}());
(function() {
    var
        JSTORAGE_VERSION = "0.2.4",
        $ = window.jQuery || window.$ || (window.$ = {}),
        JSON = {
            parse: window.JSON && (window.JSON.parse || window.JSON.decode) || String.prototype.evalJSON && function(str) {
                return String(str).evalJSON();
            } || $.parseJSON || $.evalJSON,
            stringify: window.JSON && (window.JSON.stringify || window.JSON.encode) || Object.toJSON || $.toJSON
        };
    if (!JSON.parse || !JSON.stringify) {
        throw new Error("No JSON support found, include //cdnjs.cloudflare.com/ajax/libs/json2/20110223/json2.js to page");
    }
    var
        _storage = {},
        _storage_service = {
            jStorage: "{}"
        },
        _storage_elm = null,
        _storage_size = 0,
        _backend = false,
        _observers = {},
        _observerTimeout = false,
        _observerUpdate = 0,
        _ttl_timeout, _crc32Table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 " + "0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 " + "6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 " + "FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 " + "A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 " + "32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 " + "56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 " + "C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 " + "E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 " + "6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 " + "12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE " + "A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 " + "DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 " + "5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 " + "2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF " + "04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 " + "7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 " + "FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 " + "A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C " + "36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 " + "5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 " + "C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 " + "EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D " + "7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 " + "18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 " + "A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A " + "D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A " + "53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 " + "2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D",
        _XMLService = {
            isXML: function(elm) {
                var documentElement = (elm ? elm.ownerDocument || elm : 0).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            },
            encode: function(xmlNode) {
                if (!this.isXML(xmlNode)) {
                    return false;
                }
                try {
                    return new XMLSerializer().serializeToString(xmlNode);
                } catch (E1) {
                    try {
                        return xmlNode.xml;
                    } catch (E2) {}
                }
                return false;
            },
            decode: function(xmlString) {
                var dom_parser = ("DOMParser" in window && (new DOMParser()).parseFromString) || (window.ActiveXObject && function(_xmlString) {
                        var xml_doc = new ActiveXObject('Microsoft.XMLDOM');
                        xml_doc.async = 'false';
                        xml_doc.loadXML(_xmlString);
                        return xml_doc;
                    }),
                    resultXML;
                if (!dom_parser) {
                    return false;
                }
                resultXML = dom_parser.call("DOMParser" in window && (new DOMParser()) || window, xmlString, 'text/xml');
                return this.isXML(resultXML) ? resultXML : false;
            }
        };

    function _init() {
        var localStorageReallyWorks = false;
        if ("localStorage" in window) {
            try {
                window.localStorage.setItem('_tmptest', 'tmpval');
                localStorageReallyWorks = true;
                window.localStorage.removeItem('_tmptest');
            } catch (BogusQuotaExceededErrorOnIos5) {}
        }
        if (localStorageReallyWorks) {
            try {
                if (window.localStorage) {
                    _storage_service = window.localStorage;
                    _backend = "localStorage";
                    _observerUpdate = _storage_service.jStorage_update;
                }
            } catch (E3) {}
        } else if ("globalStorage" in window) {
            try {
                if (window.globalStorage) {
                    _storage_service = window.globalStorage[window.location.hostname];
                    _backend = "globalStorage";
                    _observerUpdate = _storage_service.jStorage_update;
                }
            } catch (E4) {}
        } else {
            _storage_elm = document.createElement('link');
            if (_storage_elm.addBehavior) {
                _storage_elm.style.behavior = 'url(#default#userData)';
                document.getElementsByTagName('head')[0].appendChild(_storage_elm);
                _storage_elm.load("jStorage");
                var data = "{}";
                try {
                    data = _storage_elm.getAttribute("jStorage");
                } catch (E5) {}
                try {
                    _observerUpdate = _storage_elm.getAttribute("jStorage_update");
                } catch (E6) {}
                _storage_service.jStorage = data;
                _backend = "userDataBehavior";
            } else {
                _storage_elm = null;
                return;
            }
        }
        _load_storage();
        _handleTTL();
        _setupObserver();
        if ("addEventListener" in window) {
            window.addEventListener("pageshow", function(event) {
                if (event.persisted) {
                    _storageObserver();
                }
            }, false);
        }
    }

    function _reloadData() {
        var data = "{}";
        if (_backend == "userDataBehavior") {
            _storage_elm.load("jStorage");
            try {
                data = _storage_elm.getAttribute("jStorage");
            } catch (E5) {}
            try {
                _observerUpdate = _storage_elm.getAttribute("jStorage_update");
            } catch (E6) {}
            _storage_service.jStorage = data;
        }
        _load_storage();
        _handleTTL();
    }

    function _setupObserver() {
        if (_backend == "localStorage" || _backend == "globalStorage") {
            if ("addEventListener" in window) {
                window.addEventListener("storage", _storageObserver, false);
            } else {
                document.attachEvent("onstorage", _storageObserver);
            }
        } else if (_backend == "userDataBehavior") {
            setInterval(_storageObserver, 1000);
        }
    }

    function _storageObserver() {
        var updateTime;
        clearTimeout(_observerTimeout);
        _observerTimeout = setTimeout(function() {
            if (_backend == "localStorage" || _backend == "globalStorage") {
                updateTime = _storage_service.jStorage_update;
            } else if (_backend == "userDataBehavior") {
                _storage_elm.load("jStorage");
                try {
                    updateTime = _storage_elm.getAttribute("jStorage_update");
                } catch (E5) {}
            }
            if (updateTime && updateTime != _observerUpdate) {
                _observerUpdate = updateTime;
                _checkUpdatedKeys();
            }
        }, 100);
    }

    function _checkUpdatedKeys() {
        var oldCrc32List = JSON.parse(JSON.stringify(_storage.__jstorage_meta.CRC32)),
            newCrc32List;
        _reloadData();
        newCrc32List = JSON.parse(JSON.stringify(_storage.__jstorage_meta.CRC32));
        var key, updated = [],
            removed = [];
        for (key in oldCrc32List) {
            if (oldCrc32List.hasOwnProperty(key)) {
                if (!newCrc32List[key]) {
                    removed.push(key);
                    continue;
                }
                if (oldCrc32List[key] != newCrc32List[key]) {
                    updated.push(key);
                }
            }
        }
        for (key in newCrc32List) {
            if (newCrc32List.hasOwnProperty(key)) {
                if (!oldCrc32List[key]) {
                    updated.push(key);
                }
            }
        }
        _fireObservers(updated, "updated");
        _fireObservers(removed, "deleted");
    }

    function _fireObservers(keys, action) {
        keys = [].concat(keys || []);
        if (action == "flushed") {
            keys = [];
            for (var key in _observers) {
                if (_observers.hasOwnProperty(key)) {
                    keys.push(key);
                }
            }
            action = "deleted";
        }
        for (var i = 0, len = keys.length; i < len; i++) {
            if (_observers[keys[i]]) {
                for (var j = 0, jlen = _observers[keys[i]].length; j < jlen; j++) {
                    _observers[keys[i]][j](keys[i], action);
                }
            }
        }
    }

    function _publishChange() {
        var updateTime = (+new Date()).toString();
        if (_backend == "localStorage" || _backend == "globalStorage") {
            _storage_service.jStorage_update = updateTime;
        } else if (_backend == "userDataBehavior") {
            _storage_elm.setAttribute("jStorage_update", updateTime);
            _storage_elm.save("jStorage");
        }
        _storageObserver();
    }

    function _load_storage() {
        if (_storage_service.jStorage) {
            try {
                _storage = JSON.parse(String(_storage_service.jStorage));
            } catch (E6) {
                _storage_service.jStorage = "{}";
            }
        } else {
            _storage_service.jStorage = "{}";
        }
        _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
        if (!_storage.__jstorage_meta) {
            _storage.__jstorage_meta = {};
        }
        if (!_storage.__jstorage_meta.CRC32) {
            _storage.__jstorage_meta.CRC32 = {};
        }
    }

    function _save() {
        try {
            _storage_service.jStorage = JSON.stringify(_storage);
            if (_storage_elm) {
                _storage_elm.setAttribute("jStorage", _storage_service.jStorage);
                _storage_elm.save("jStorage");
            }
            _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
        } catch (E7) {}
    }

    function _checkKey(key) {
        if (!key || (typeof key != "string" && typeof key != "number")) {
            throw new TypeError('Key name must be string or numeric');
        }
        if (key == "__jstorage_meta") {
            throw new TypeError('Reserved key name');
        }
        return true;
    }

    function _handleTTL() {
        var curtime, i, TTL, CRC32, nextExpire = Infinity,
            changed = false,
            deleted = [];
        clearTimeout(_ttl_timeout);
        if (!_storage.__jstorage_meta || typeof _storage.__jstorage_meta.TTL != "object") {
            return;
        }
        curtime = +new Date();
        TTL = _storage.__jstorage_meta.TTL;
        CRC32 = _storage.__jstorage_meta.CRC32;
        for (i in TTL) {
            if (TTL.hasOwnProperty(i)) {
                if (TTL[i] <= curtime) {
                    delete TTL[i];
                    delete CRC32[i];
                    delete _storage[i];
                    changed = true;
                    deleted.push(i);
                } else if (TTL[i] < nextExpire) {
                    nextExpire = TTL[i];
                }
            }
        }
        if (nextExpire != Infinity) {
            _ttl_timeout = setTimeout(_handleTTL, nextExpire - curtime);
        }
        if (changed) {
            _save();
            _publishChange();
            _fireObservers(deleted, "deleted");
        }
    }

    function _crc32(str, crc) {
        crc = crc || 0;
        var n = 0,
            x = 0;
        crc = crc ^ (-1);
        for (var i = 0, len = str.length; i < len; i++) {
            n = (crc ^ str.charCodeAt(i)) & 0xFF;
            x = "0x" + _crc32Table.substr(n * 9, 8);
            crc = (crc >>> 8) ^ x;
        }
        return crc ^ (-1);
    }
    $.jStorage = {
        version: JSTORAGE_VERSION,
        set: function(key, value, options) {
            _checkKey(key);
            options = options || {};
            if (typeof value == "undefined") {
                this.deleteKey(key);
                return value;
            }
            if (_XMLService.isXML(value)) {
                value = {
                    _is_xml: true,
                    xml: _XMLService.encode(value)
                };
            } else if (typeof value == "function") {
                return undefined;
            } else if (value && typeof value == "object") {
                value = JSON.parse(JSON.stringify(value));
            }
            _storage[key] = value;
            _storage.__jstorage_meta.CRC32[key] = _crc32(JSON.stringify(value));
            this.setTTL(key, options.TTL || 0);
            _fireObservers(key, "updated");
            return value;
        },
        get: function(key, def) {
            _checkKey(key);
            if (key in _storage) {
                if (_storage[key] && typeof _storage[key] == "object" && _storage[key]._is_xml && _storage[key]._is_xml) {
                    return _XMLService.decode(_storage[key].xml);
                } else {
                    return _storage[key];
                }
            }
            return typeof(def) == 'undefined' ? null : def;
        },
        deleteKey: function(key) {
            _checkKey(key);
            if (key in _storage) {
                delete _storage[key];
                if (typeof _storage.__jstorage_meta.TTL == "object" && key in _storage.__jstorage_meta.TTL) {
                    delete _storage.__jstorage_meta.TTL[key];
                }
                delete _storage.__jstorage_meta.CRC32[key];
                _save();
                _publishChange();
                _fireObservers(key, "deleted");
                return true;
            }
            return false;
        },
        setTTL: function(key, ttl) {
            var curtime = +new Date();
            _checkKey(key);
            ttl = Number(ttl) || 0;
            if (key in _storage) {
                if (!_storage.__jstorage_meta.TTL) {
                    _storage.__jstorage_meta.TTL = {};
                }
                if (ttl > 0) {
                    _storage.__jstorage_meta.TTL[key] = curtime + ttl;
                } else {
                    delete _storage.__jstorage_meta.TTL[key];
                }
                _save();
                _handleTTL();
                _publishChange();
                return true;
            }
            return false;
        },
        getTTL: function(key) {
            var curtime = +new Date(),
                ttl;
            _checkKey(key);
            if (key in _storage && _storage.__jstorage_meta.TTL && _storage.__jstorage_meta.TTL[key]) {
                ttl = _storage.__jstorage_meta.TTL[key] - curtime;
                return ttl || 0;
            }
            return 0;
        },
        flush: function() {
            _storage = {
                __jstorage_meta: {
                    CRC32: {}
                }
            };
            _save();
            _publishChange();
            _fireObservers(null, "flushed");
            return true;
        },
        storageObj: function() {
            function F() {}
            F.prototype = _storage;
            return new F();
        },
        index: function() {
            var index = [],
                i;
            for (i in _storage) {
                if (_storage.hasOwnProperty(i) && i != "__jstorage_meta") {
                    index.push(i);
                }
            }
            return index;
        },
        storageSize: function() {
            return _storage_size;
        },
        currentBackend: function() {
            return _backend;
        },
        storageAvailable: function() {
            return !!_backend;
        },
        listenKeyChange: function(key, callback) {
            _checkKey(key);
            if (!_observers[key]) {
                _observers[key] = [];
            }
            _observers[key].push(callback);
        },
        stopListening: function(key, callback) {
            _checkKey(key);
            if (!_observers[key]) {
                return;
            }
            if (!callback) {
                delete _observers[key];
                return;
            }
            for (var i = _observers[key].length - 1; i >= 0; i--) {
                if (_observers[key][i] == callback) {
                    _observers[key].splice(i, 1);
                }
            }
        },
        reInit: function() {
            _reloadData();
        }
    };
    _init();
})();;
(function($) {
    var $scrollTo = $.scrollTo = function(target, duration, settings) {
        jQuery(window).scrollTo(target, duration, settings);
    };
    $scrollTo.defaults = {
        axis: 'xy',
        duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1,
        limit: true
    };
    $scrollTo.window = function(scope) {
        return jQuery(window)._scrollable();
    };
    $.fn._scrollable = function() {
        return this.map(function() {
            var elem = this,
                isWin = !elem.nodeName || $.inArray(elem.nodeName.toLowerCase(), ['iframe', '#document', 'html', 'body']) != -1;
            if (!isWin)
                return elem;
            var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
            return /webkit/i.test(navigator.userAgent) || doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;
        });
    };
    $.fn.scrollTo = function(target, duration, settings) {
        if (typeof duration == 'object') {
            settings = duration;
            duration = 0;
        }
        if (typeof settings == 'function')
            settings = {
                onAfter: settings
            };
        if (target == 'max')
            target = 9e9;
        settings = $.extend({}, $scrollTo.defaults, settings);
        duration = duration || settings.duration;
        settings.queue = settings.queue && settings.axis.length > 1;
        if (settings.queue)
            duration /= 2;
        settings.offset = both(settings.offset);
        settings.over = both(settings.over);
        return this._scrollable().each(function() {
            if (!target) return;
            var elem = this,
                $elem = jQuery(elem),
                targ = target,
                toff, attr = {},
                win = $elem.is('html,body');
            switch (typeof targ) {
                case 'number':
                case 'string':
                    if (/^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
                        targ = both(targ);
                        break;
                    }
                    targ = jQuery(targ, this);
                    if (!targ.length) return;
                case 'object':
                    if (targ.is || targ.style)
                        toff = (targ = jQuery(targ)).offset();
            }
            $.each(settings.axis.split(''), function(i, axis) {
                var Pos = axis == 'x' ? 'Left' : 'Top',
                    pos = Pos.toLowerCase(),
                    key = 'scroll' + Pos,
                    old = elem[key],
                    max = $scrollTo.max(elem, axis);
                if (toff) {
                    attr[key] = toff[pos] + (win ? 0 : old - $elem.offset()[pos]);
                    if (settings.margin) {
                        attr[key] -= parseInt(targ.css('margin' + Pos)) || 0;
                        attr[key] -= parseInt(targ.css('border' + Pos + 'Width')) || 0;
                    }
                    attr[key] += settings.offset[pos] || 0;
                    if (settings.over[pos])
                        attr[key] += targ[axis == 'x' ? 'width' : 'height']() * settings.over[pos];
                } else {
                    var val = targ[pos];
                    attr[key] = val.slice && val.slice(-1) == '%' ? parseFloat(val) / 100 * max : val;
                }
                if (settings.limit && /^\d+$/.test(attr[key]))
                    attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
                if (!i && settings.queue) {
                    if (old != attr[key])
                        animate(settings.onAfterFirst);
                    delete attr[key];
                }
            });
            animate(settings.onAfter);

            function animate(callback) {
                $elem.animate(attr, duration, settings.easing, callback && function() {
                    callback.call(this, target, settings);
                });
            };
        }).end();
    };
    $scrollTo.max = function(elem, axis) {
        var Dim = axis == 'x' ? 'Width' : 'Height',
            scroll = 'scroll' + Dim;
        if (!jQuery(elem).is('html,body'))
            return elem[scroll] - jQuery(elem)[Dim.toLowerCase()]();
        var size = 'client' + Dim,
            html = elem.ownerDocument.documentElement,
            body = elem.ownerDocument.body;
        return Math.max(html[scroll], body[scroll]) -
            Math.min(html[size], body[size]);
    };

    function both(val) {
        return typeof val == 'object' ? val : {
            top: val,
            left: val
        };
    };
})(jQuery);;
(function($) {
    var NAMESPACE = '.serialScroll';
    var $serialScroll = $.serialScroll = function(settings) {
        return jQuery(window).serialScroll(settings);
    };
    $serialScroll.defaults = {
        duration: 1000,
        axis: 'x',
        event: 'click',
        start: 0,
        step: 1,
        lock: true,
        cycle: true,
        constant: true
    };
    $.fn.serialScroll = function(options) {
        return this.each(function() {
            var
                settings = $.extend({}, $serialScroll.defaults, options),
                event = settings.event,
                step = settings.step,
                lazy = settings.lazy,
                context = settings.target ? this : document,
                $pane = jQuery(settings.target || this, context),
                pane = $pane[0],
                items = settings.items,
                active = settings.start,
                auto = settings.interval,
                nav = settings.navigation,
                timer;
            if (!pane)
                return;
            if (!lazy)
                items = getItems();
            if (settings.force || auto)
                jump({}, active);
            jQuery(settings.prev || [], context).bind(event, -step, move);
            jQuery(settings.next || [], context).bind(event, step, move);
            if (!pane.ssbound)
                $pane.bind('prev' + NAMESPACE, -step, move).bind('next' + NAMESPACE, step, move).bind('goto' + NAMESPACE, jump);
            if (auto)
                $pane.bind('start' + NAMESPACE, function(e) {
                    if (!auto) {
                        clear();
                        auto = true;
                        next();
                    }
                }).bind('stop' + NAMESPACE, function() {
                    clear();
                    auto = false;
                });
            $pane.bind('notify' + NAMESPACE, function(e, elem) {
                var i = index(elem);
                if (i > -1)
                    active = i;
            });
            pane.ssbound = true;
            if (settings.jump)
                (lazy ? $pane : getItems()).bind(event, function(e) {
                    jump(e, index(e.target));
                });
            if (nav)
                nav = jQuery(nav, context).bind(event, function(e) {
                    e.data = Math.round(getItems().length / nav.length) * nav.index(this);
                    jump(e, this);
                });

            function move(e) {
                e.data += active;
                jump(e, this);
            };

            function jump(e, pos) {
                if (isNaN(pos))
                    pos = e.data;
                var n, real = e.type,
                    $items = settings.exclude ? getItems().slice(0, -settings.exclude) : getItems(),
                    limit = $items.length - 1,
                    elem = $items[pos],
                    duration = settings.duration;
                if (real)
                    e.preventDefault();
                if (auto) {
                    clear();
                    timer = setTimeout(next, settings.interval);
                }
                if (!elem) {
                    n = pos < 0 ? 0 : limit;
                    if (active !== n)
                        pos = n;
                    else if (!settings.cycle)
                        return;
                    else
                        pos = limit - n;
                    elem = $items[pos];
                }
                if (!elem || settings.lock && $pane._scrollable().is(':animated') || real && settings.onBefore && settings.onBefore(e, elem, $pane, getItems(), pos) === false) return;
                if (settings.stop)
                    $pane._scrollable().stop(true);
                if (settings.constant)
                    duration = Math.abs(duration / step * (active - pos));
                $pane.scrollTo(elem, duration, settings);
                trigger('notify', pos);
            };

            function next() {
                trigger('next');
            };

            function clear() {
                clearTimeout(timer);
            };

            function getItems() {
                return jQuery(items, pane);
            };

            function trigger(event) {
                $pane.trigger(event + NAMESPACE, [].slice.call(arguments, 1));
            }

            function index(elem) {
                if (!isNaN(elem))
                    return elem;
                var $items = getItems(),
                    i;
                while ((i = $items.index(elem)) === -1 && elem !== pane)
                    elem = elem.parentNode;
                return i;
            };
        });
    };
})(jQuery);
(function($, document, undefined) {
    var pluses = /\+/g;

    function raw(s) {
        return s;
    }

    function decoded(s) {
        return decodeURIComponent(s.replace(pluses, ' '));
    }
    var config = jQuery.cookie = function(key, value, options) {
        if (value !== undefined) {
            options = jQuery.extend({}, config.defaults, options);
            if (value === null) {
                options.expires = -1;
            }
            if (typeof options.expires === 'number') {
                var days = options.expires,
                    t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }
            value = config.json ? JSON.stringify(value) : String(value);
            return (document.cookie = [encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join(''));
        }
        var decode = config.raw ? raw : decoded;
        var cookies = document.cookie.split('; ');
        for (var i = 0, parts;
            (parts = cookies[i] && cookies[i].split('=')); i++) {
            if (decode(parts.shift()) === key) {
                var cookie = decode(parts.join('='));
                return config.json ? JSON.parse(cookie) : cookie;
            }
        }
        return null;
    };
    config.defaults = {};
    jQuery.removeCookie = function(key, options) {
        if (jQuery.cookie(key, options) !== null) {
            jQuery.cookie(key, null, options);
            return true;
        }
        return false;
    };
})(jQuery, document);
var Base64 = (function() {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var obj = {
        encode: function(input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
                if (isNaN(chr2)) {
                    enc3 = enc4 = 64
                } else {
                    if (isNaN(chr3)) {
                        enc4 = 64
                    }
                }
                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4)
            } while (i < input.length);
            return output
        },
        decode: function(input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));
                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;
                output = output + String.fromCharCode(chr1);
                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2)
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3)
                }
            } while (i < input.length);
            return output
        }
    };
    return obj
})();
var MD5 = (function() {
    var hexcase = 0;
    var b64pad = "";
    var chrsz = 8;
    var safe_add = function(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 65535)
    };
    var bit_rol = function(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt))
    };
    var str2binl = function(str) {
        var bin = [];
        var mask = (1 << chrsz) - 1;
        for (var i = 0; i < str.length * chrsz; i += chrsz) {
            bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (i % 32)
        }
        return bin
    };
    var binl2str = function(bin) {
        var str = "";
        var mask = (1 << chrsz) - 1;
        for (var i = 0; i < bin.length * 32; i += chrsz) {
            str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & mask)
        }
        return str
    };
    var binl2hex = function(binarray) {
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for (var i = 0; i < binarray.length * 4; i++) {
            str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 15) + hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 15)
        }
        return str
    };
    var binl2b64 = function(binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        var triplet, j;
        for (var i = 0; i < binarray.length * 4; i += 3) {
            triplet = (((binarray[i >> 2] >> 8 * (i % 4)) & 255) << 16) | (((binarray[i + 1 >> 2] >> 8 * ((i + 1) % 4)) & 255) << 8) | ((binarray[i + 2 >> 2] >> 8 * ((i + 2) % 4)) & 255);
            for (j = 0; j < 4; j++) {
                if (i * 8 + j * 6 > binarray.length * 32) {
                    str += b64pad
                } else {
                    str += tab.charAt((triplet >> 6 * (3 - j)) & 63)
                }
            }
        }
        return str
    };
    var md5_cmn = function(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
    };
    var md5_ff = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
    };
    var md5_gg = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
    };
    var md5_hh = function(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t)
    };
    var md5_ii = function(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
    };
    var core_md5 = function(x, len) {
        x[len >> 5] |= 128 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd)
        }
        return [a, b, c, d]
    };
    var core_hmac_md5 = function(key, data) {
        var bkey = str2binl(key);
        if (bkey.length > 16) {
            bkey = core_md5(bkey, key.length * chrsz)
        }
        var ipad = new Array(16),
            opad = new Array(16);
        for (var i = 0; i < 16; i++) {
            ipad[i] = bkey[i] ^ 909522486;
            opad[i] = bkey[i] ^ 1549556828
        }
        var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
        return core_md5(opad.concat(hash), 512 + 128)
    };
    var obj = {
        hexdigest: function(s) {
            return binl2hex(core_md5(str2binl(s), s.length * chrsz))
        },
        b64digest: function(s) {
            return binl2b64(core_md5(str2binl(s), s.length * chrsz))
        },
        hash: function(s) {
            return binl2str(core_md5(str2binl(s), s.length * chrsz))
        },
        hmac_hexdigest: function(key, data) {
            return binl2hex(core_hmac_md5(key, data))
        },
        hmac_b64digest: function(key, data) {
            return binl2b64(core_hmac_md5(key, data))
        },
        hmac_hash: function(key, data) {
            return binl2str(core_hmac_md5(key, data))
        },
        test: function() {
            return MD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72"
        }
    };
    return obj
})();
if (!Function.prototype.bind) {
    Function.prototype.bind = function(obj) {
        var func = this;
        return function() {
            return func.apply(obj, arguments)
        }
    }
}
if (!Function.prototype.prependArg) {
    Function.prototype.prependArg = function(arg) {
        var func = this;
        return function() {
            var newargs = [arg];
            for (var i = 0; i < arguments.length; i++) {
                newargs.push(arguments[i])
            }
            return func.apply(this, newargs)
        }
    }
}
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(elt) {
        var len = this.length;
        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
            from += len
        }
        for (; from < len; from++) {
            if (from in this && this[from] === elt) {
                return from
            }
        }
        return -1
    }
}(function(callback) {
    var Strophe;

    function $build(name, attrs) {
        return new Strophe.Builder(name, attrs)
    }

    function $msg(attrs) {
        return new Strophe.Builder("message", attrs)
    }

    function $iq(attrs) {
        return new Strophe.Builder("iq", attrs)
    }

    function $pres(attrs) {
        return new Strophe.Builder("presence", attrs)
    }
    Strophe = {
        VERSION: "1.0.1",
        NS: {
            HTTPBIND: "http://jabber.org/protocol/httpbind",
            BOSH: "urn:xmpp:xbosh",
            CLIENT: "jabber:client",
            AUTH: "jabber:iq:auth",
            ROSTER: "jabber:iq:roster",
            PROFILE: "jabber:iq:profile",
            DISCO_INFO: "http://jabber.org/protocol/disco#info",
            DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
            MUC: "http://jabber.org/protocol/muc",
            SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
            STREAM: "http://etherx.jabber.org/streams",
            BIND: "urn:ietf:params:xml:ns:xmpp-bind",
            SESSION: "urn:ietf:params:xml:ns:xmpp-session",
            VERSION: "jabber:iq:version",
            STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas"
        },
        addNamespace: function(name, value) {
            Strophe.NS[name] = value
        },
        Status: {
            ERROR: 0,
            CONNECTING: 1,
            CONNFAIL: 2,
            AUTHENTICATING: 3,
            AUTHFAIL: 4,
            CONNECTED: 5,
            DISCONNECTED: 6,
            DISCONNECTING: 7,
            ATTACHED: 8
        },
        LogLevel: {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            FATAL: 4
        },
        ElementType: {
            NORMAL: 1,
            TEXT: 3
        },
        TIMEOUT: 1.1,
        SECONDARY_TIMEOUT: 0.1,
        forEachChild: function(elem, elemName, func) {
            var i, childNode;
            for (i = 0; i < elem.childNodes.length; i++) {
                childNode = elem.childNodes[i];
                if (childNode.nodeType == Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
                    func(childNode)
                }
            }
        },
        isTagEqual: function(el, name) {
            return el.tagName.toLowerCase() == name.toLowerCase()
        },
        _xmlGenerator: null,
        _makeGenerator: function() {
            var doc;
            if (window.ActiveXObject) {
                doc = new ActiveXObject("Microsoft.XMLDOM");
                doc.appendChild(doc.createElement("strophe"))
            } else {
                doc = document.implementation.createDocument("jabber:client", "strophe", null)
            }
            return doc
        },
        xmlElement: function(name) {
            if (!name) {
                return null
            }
            var node = null;
            if (!Strophe._xmlGenerator) {
                Strophe._xmlGenerator = Strophe._makeGenerator()
            }
            node = Strophe._xmlGenerator.createElement(name);
            var a, i, k;
            for (a = 1; a < arguments.length; a++) {
                if (!arguments[a]) {
                    continue
                }
                if (typeof(arguments[a]) == "string" || typeof(arguments[a]) == "number") {
                    node.appendChild(Strophe.xmlTextNode(arguments[a]))
                } else {
                    if (typeof(arguments[a]) == "object" && typeof(arguments[a].sort) == "function") {
                        for (i = 0; i < arguments[a].length; i++) {
                            if (typeof(arguments[a][i]) == "object" && typeof(arguments[a][i].sort) == "function") {
                                node.setAttribute(arguments[a][i][0], arguments[a][i][1])
                            }
                        }
                    } else {
                        if (typeof(arguments[a]) == "object") {
                            for (k in arguments[a]) {
                                if (arguments[a].hasOwnProperty(k)) {
                                    node.setAttribute(k, arguments[a][k])
                                }
                            }
                        }
                    }
                }
            }
            return node
        },
        xmlescape: function(text) {
            text = text.replace(/\&/g, "&amp;");
            text = text.replace(/</g, "&lt;");
            text = text.replace(/>/g, "&gt;");
            return text
        },
        xmlTextNode: function(text) {
            text = Strophe.xmlescape(text);
            if (!Strophe._xmlGenerator) {
                Strophe._xmlGenerator = Strophe._makeGenerator()
            }
            return Strophe._xmlGenerator.createTextNode(text)
        },
        getText: function(elem) {
            if (!elem) {
                return null
            }
            var str = "";
            if (elem.childNodes.length === 0 && elem.nodeType == Strophe.ElementType.TEXT) {
                str += elem.nodeValue
            }
            for (var i = 0; i < elem.childNodes.length; i++) {
                if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                    str += elem.childNodes[i].nodeValue
                }
            }
            return str
        },
        copyElement: function(elem) {
            var i, el;
            if (elem.nodeType == Strophe.ElementType.NORMAL) {
                el = Strophe.xmlElement(elem.tagName);
                for (i = 0; i < elem.attributes.length; i++) {
                    el.setAttribute(elem.attributes[i].nodeName.toLowerCase(), elem.attributes[i].value)
                }
                for (i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.copyElement(elem.childNodes[i]))
                }
            } else {
                if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlTextNode(elem.nodeValue)
                }
            }
            return el
        },
        escapeNode: function(node) {
            return node.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
        },
        unescapeNode: function(node) {
            return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
        },
        getNodeFromJid: function(jid) {
            if (jid.indexOf("@") < 0) {
                return null
            }
            return jid.split("@")[0]
        },
        getDomainFromJid: function(jid) {
            var bare = Strophe.getBareJidFromJid(jid);
            if (bare.indexOf("@") < 0) {
                return bare
            } else {
                var parts = bare.split("@");
                parts.splice(0, 1);
                return parts.join("@")
            }
        },
        getResourceFromJid: function(jid) {
            var s = jid.split("/");
            if (s.length < 2) {
                return null
            }
            s.splice(0, 1);
            return s.join("/")
        },
        getBareJidFromJid: function(jid) {
            return jid.split("/")[0]
        },
        log: function(level, msg) {
            return
        },
        debug: function(msg) {
            this.log(this.LogLevel.DEBUG, msg)
        },
        info: function(msg) {
            this.log(this.LogLevel.INFO, msg)
        },
        warn: function(msg) {
            this.log(this.LogLevel.WARN, msg)
        },
        error: function(msg) {
            this.log(this.LogLevel.ERROR, msg)
        },
        fatal: function(msg) {
            this.log(this.LogLevel.FATAL, msg)
        },
        serialize: function(elem) {
            var result;
            if (!elem) {
                return null
            }
            if (typeof(elem.tree) === "function") {
                elem = elem.tree()
            }
            var nodeName = elem.nodeName;
            var i, child;
            if (elem.getAttribute("_realname")) {
                nodeName = elem.getAttribute("_realname")
            }
            result = "<" + nodeName;
            for (i = 0; i < elem.attributes.length; i++) {
                if (elem.attributes[i].nodeName != "_realname") {
                    result += " " + elem.attributes[i].nodeName.toLowerCase() + "='" + elem.attributes[i].value.replace("&", "&amp;").replace("'", "&apos;").replace("<", "&lt;") + "'"
                }
            }
            if (elem.childNodes.length > 0) {
                result += ">";
                for (i = 0; i < elem.childNodes.length; i++) {
                    child = elem.childNodes[i];
                    if (child.nodeType == Strophe.ElementType.NORMAL) {
                        result += Strophe.serialize(child)
                    } else {
                        if (child.nodeType == Strophe.ElementType.TEXT) {
                            result += child.nodeValue
                        }
                    }
                }
                result += "</" + nodeName + ">"
            } else {
                result += "/>"
            }
            return result
        },
        _requestId: 0,
        _connectionPlugins: {},
        addConnectionPlugin: function(name, ptype) {
            Strophe._connectionPlugins[name] = ptype
        }
    };
    Strophe.Builder = function(name, attrs) {
        if (name == "presence" || name == "message" || name == "iq") {
            if (attrs && !attrs.xmlns) {
                attrs.xmlns = Strophe.NS.CLIENT
            } else {
                if (!attrs) {
                    attrs = {
                        xmlns: Strophe.NS.CLIENT
                    }
                }
            }
        }
        this.nodeTree = Strophe.xmlElement(name, attrs);
        this.node = this.nodeTree
    };
    Strophe.Builder.prototype = {
        tree: function() {
            return this.nodeTree
        },
        toString: function() {
            return Strophe.serialize(this.nodeTree)
        },
        up: function() {
            this.node = this.node.parentNode;
            return this
        },
        attrs: function(moreattrs) {
            for (var k in moreattrs) {
                if (moreattrs.hasOwnProperty(k)) {
                    this.node.setAttribute(k, moreattrs[k])
                }
            }
            return this
        },
        c: function(name, attrs) {
            var child = Strophe.xmlElement(name, attrs);
            this.node.appendChild(child);
            this.node = child;
            return this
        },
        cnode: function(elem) {
            this.node.appendChild(elem);
            this.node = elem;
            return this
        },
        t: function(text) {
            var child = Strophe.xmlTextNode(text);
            this.node.appendChild(child);
            return this
        }
    };
    Strophe.Handler = function(handler, ns, name, type, id, from, options) {
        this.handler = handler;
        this.ns = ns;
        this.name = name;
        this.type = type;
        this.id = id;
        this.options = options || {
            matchbare: false
        };
        if (!this.options.matchBare) {
            this.options.matchBare = false
        }
        if (this.options.matchBare) {
            this.from = Strophe.getBareJidFromJid(from)
        } else {
            this.from = from
        }
        this.user = true
    };
    Strophe.Handler.prototype = {
        isMatch: function(elem) {
            var nsMatch;
            var from = null;
            if (this.options.matchBare) {
                from = Strophe.getBareJidFromJid(elem.getAttribute("from"))
            } else {
                from = elem.getAttribute("from")
            }
            nsMatch = false;
            if (!this.ns) {
                nsMatch = true
            } else {
                var self = this;
                Strophe.forEachChild(elem, null, function(elem) {
                    if (elem.getAttribute("xmlns") == self.ns) {
                        nsMatch = true
                    }
                });
                nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns
            }
            if (nsMatch && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || elem.getAttribute("type") === this.type) && (!this.id || elem.getAttribute("id") === this.id) && (!this.from || from === this.from)) {
                return true
            }
            return false
        },
        run: function(elem) {
            var result = null;
            try {
                result = this.handler(elem)
            } catch (e) {
                if (e.sourceURL) {
                    Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message)
                } else {
                    if (e.fileName) {
                        if (typeof(console) != "undefined") {
                            console.trace();
                            console.error(this.handler, " - error - ", e, e.message)
                        }
                        Strophe.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message)
                    } else {
                        Strophe.fatal("error: " + this.handler)
                    }
                }
                throw e
            }
            return result
        },
        toString: function() {
            return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
        }
    };
    Strophe.TimedHandler = function(period, handler) {
        this.period = period;
        this.handler = handler;
        this.lastCalled = new Date().getTime();
        this.user = true
    };
    Strophe.TimedHandler.prototype = {
        run: function() {
            this.lastCalled = new Date().getTime();
            return this.handler()
        },
        reset: function() {
            this.lastCalled = new Date().getTime()
        },
        toString: function() {
            return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
        }
    };
    Strophe.Request = function(elem, func, rid, sends) {
        this.id = ++Strophe._requestId;
        this.xmlData = elem;
        this.data = Strophe.serialize(elem);
        this.origFunc = func;
        this.func = func;
        this.rid = rid;
        this.date = NaN;
        this.sends = sends || 0;
        this.abort = false;
        this.dead = null;
        this.age = function() {
            if (!this.date) {
                return 0
            }
            var now = new Date();
            return (now - this.date) / 1000
        };
        this.timeDead = function() {
            if (!this.dead) {
                return 0
            }
            var now = new Date();
            return (now - this.dead) / 1000
        };
        this.xhr = this._newXHR()
    };
    Strophe.Request.prototype = {
        getResponse: function() {
            var node = null;
            if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                node = this.xhr.responseXML.documentElement;
                if (node.tagName == "parsererror") {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML));
                    throw "parsererror"
                }
            } else {
                if (this.xhr.responseText) {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML))
                }
            }
            return node
        },
        _newXHR: function() {
            var xhr = null;
            if (window.XMLHttpRequest) {
                xhr = new XMLHttpRequest();
                if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/xml")
                }
            } else {
                if (window.ActiveXObject) {
                    xhr = new ActiveXObject("Microsoft.XMLHTTP")
                }
            }
            xhr.onreadystatechange = this.func.prependArg(this);
            return xhr
        }
    };
    Strophe.Connection = function(service) {
        this.service = service;
        this.jid = "";
        this.rid = Math.floor(Math.random() * 4294967295);
        this.sid = null;
        this.streamId = null;
        this.do_session = false;
        this.do_bind = false;
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
        this._idleTimeout = null;
        this._disconnectTimeout = null;
        this.authenticated = false;
        this.disconnecting = false;
        this.connected = false;
        this.errors = 0;
        this.paused = false;
        this.hold = 1;
        this.wait = 60;
        this.window = 5;
        this._data = [];
        this._requests = [];
        this._uniqueId = Math.round(Math.random() * 10000);
        this._sasl_success_handler = null;
        this._sasl_failure_handler = null;
        this._sasl_challenge_handler = null;
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var ptype = Strophe._connectionPlugins[k];
                var F = function() {};
                F.prototype = ptype;
                this[k] = new F();
                this[k].init(this)
            }
        }
    };
    Strophe.Connection.prototype = {
        reset: function() {
            this.rid = Math.floor(Math.random() * 4294967295);
            this.sid = null;
            this.streamId = null;
            this.do_session = false;
            this.do_bind = false;
            this.timedHandlers = [];
            this.handlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];
            this.authenticated = false;
            this.disconnecting = false;
            this.connected = false;
            this.errors = 0;
            this._requests = [];
            this._uniqueId = Math.round(Math.random() * 10000)
        },
        pause: function() {
            this.paused = true
        },
        resume: function() {
            this.paused = false
        },
        getUniqueId: function(suffix) {
            if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                return ++this._uniqueId + ":" + suffix
            } else {
                return ++this._uniqueId + ""
            }
        },
        connect: function(jid, pass, callback, wait, hold) {
            this.jid = jid;
            this.pass = pass;
            this.connect_callback = callback;
            this.disconnecting = false;
            this.connected = false;
            this.authenticated = false;
            this.errors = 0;
            this.wait = wait || this.wait;
            this.hold = hold || this.hold;
            this.domain = Strophe.getDomainFromJid(this.jid);
            var body = this._buildBody().attrs({
                to: this.domain,
                "xml:lang": "en",
                wait: this.wait,
                hold: this.hold,
                content: "text/xml; charset=utf-8",
                ver: "1.6",
                "xmpp:version": "1.0",
                "xmlns:xmpp": Strophe.NS.BOSH
            });
            this._changeConnectStatus(Strophe.Status.CONNECTING, null);
            this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this).prependArg(this._connect_cb.bind(this)), body.tree().getAttribute("rid")));
            this._throttledRequestHandler()
        },
        attach: function(jid, sid, rid, callback, wait, hold, wind) {
            this.jid = jid;
            this.sid = sid;
            this.rid = rid;
            this.connect_callback = callback;
            this.domain = Strophe.getDomainFromJid(this.jid);
            this.authenticated = true;
            this.connected = true;
            this.wait = wait || this.wait;
            this.hold = hold || this.hold;
            this.window = wind || this.window;
            this._changeConnectStatus(Strophe.Status.ATTACHED, null)
        },
        xmlInput: function(elem) {
            return
        },
        xmlOutput: function(elem) {
            return
        },
        rawInput: function(data) {
            return
        },
        rawOutput: function(data) {
            return
        },
        send: function(elem) {
            if (elem === null) {
                return
            }
            if (typeof(elem.sort) === "function") {
                for (var i = 0; i < elem.length; i++) {
                    this._queueData(elem[i])
                }
            } else {
                if (typeof(elem.tree) === "function") {
                    this._queueData(elem.tree())
                } else {
                    this._queueData(elem)
                }
            }
            this._throttledRequestHandler();
            clearTimeout(this._idleTimeout);
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100)
        },
        flush: function() {
            clearTimeout(this._idleTimeout);
            this._onIdle()
        },
        sendIQ: function(elem, callback, errback, timeout) {
            var timeoutHandler = null;
            var that = this;
            if (typeof(elem.tree) === "function") {
                elem = elem.tree()
            }
            var id = elem.getAttribute("id");
            if (!id) {
                id = this.getUniqueId("sendIQ");
                elem.setAttribute("id", id)
            }
            var handler = this.addHandler(function(stanza) {
                if (timeoutHandler) {
                    that.deleteTimedHandler(timeoutHandler)
                }
                var iqtype = stanza.getAttribute("type");
                if (iqtype === "result") {
                    if (callback) {
                        callback(stanza)
                    }
                } else {
                    if (iqtype === "error") {
                        if (errback) {
                            errback(stanza)
                        }
                    } else {
                        throw {
                            name: "StropheError",
                            message: "Got bad IQ type of " + iqtype
                        }
                    }
                }
            }, null, "iq", null, id);
            if (timeout) {
                timeoutHandler = this.addTimedHandler(timeout, function() {
                    that.deleteHandler(handler);
                    if (errback) {
                        errback(null)
                    }
                    return false
                })
            }
            this.send(elem);
            return id
        },
        _queueData: function(element) {
            if (element === null || !element.tagName || !element.childNodes) {
                throw {
                    name: "StropheError",
                    message: "Cannot queue non-DOMElement."
                }
            }
            this._data.push(element)
        },
        _sendRestart: function() {
            this._data.push("restart");
            this._throttledRequestHandler();
            clearTimeout(this._idleTimeout);
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100)
        },
        addTimedHandler: function(period, handler) {
            var thand = new Strophe.TimedHandler(period, handler);
            this.addTimeds.push(thand);
            return thand
        },
        deleteTimedHandler: function(handRef) {
            this.removeTimeds.push(handRef)
        },
        addHandler: function(handler, ns, name, type, id, from, options) {
            var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
            this.addHandlers.push(hand);
            return hand
        },
        deleteHandler: function(handRef) {
            this.removeHandlers.push(handRef)
        },
        disconnect: function(reason) {
            this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
            Strophe.info("Disconnect was called because: " + reason);
            if (this.connected) {
                this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));
                this._sendTerminate()
            }
        },
        _changeConnectStatus: function(status, condition) {
            for (var k in Strophe._connectionPlugins) {
                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                    var plugin = this[k];
                    if (plugin.statusChanged) {
                        try {
                            plugin.statusChanged(status, condition)
                        } catch (err) {
                            Strophe.error("" + k + " plugin caused an exception changing status: " + err)
                        }
                    }
                }
            }
            if (this.connect_callback) {
                try {
                    this.connect_callback(status, condition)
                } catch (e) {
                    Strophe.error("User connection callback caused an exception: " + e)
                }
            }
        },
        _buildBody: function() {
            var bodyWrap = $build("body", {
                rid: this.rid++,
                xmlns: Strophe.NS.HTTPBIND
            });
            if (this.sid !== null) {
                bodyWrap.attrs({
                    sid: this.sid
                })
            }
            return bodyWrap
        },
        _removeRequest: function(req) {
            Strophe.debug("removing request");
            var i;
            for (i = this._requests.length - 1; i >= 0; i--) {
                if (req == this._requests[i]) {
                    this._requests.splice(i, 1)
                }
            }
            req.xhr.onreadystatechange = function() {};
            this._throttledRequestHandler()
        },
        _restartRequest: function(i) {
            var req = this._requests[i];
            if (req.dead === null) {
                req.dead = new Date()
            }
            this._processRequest(i)
        },
        _processRequest: function(i) {
            var req = this._requests[i];
            var reqStatus = -1;
            try {
                if (req.xhr.readyState == 4) {
                    reqStatus = req.xhr.status
                }
            } catch (e) {
                Strophe.error("caught an error in _requests[" + i + "], reqStatus: " + reqStatus)
            }
            if (typeof(reqStatus) == "undefined") {
                reqStatus = -1
            }
            var time_elapsed = req.age();
            var primaryTimeout = (!isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
            var secondaryTimeout = (req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
            var requestCompletedWithServerError = (req.xhr.readyState == 4 && (reqStatus < 1 || reqStatus >= 500));
            if (primaryTimeout || secondaryTimeout || requestCompletedWithServerError) {
                if (secondaryTimeout) {
                    Strophe.error("Request " + this._requests[i].id + " timed out (secondary), restarting")
                }
                req.abort = true;
                req.xhr.abort();
                req.xhr.onreadystatechange = function() {};
                this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);
                req = this._requests[i]
            }
            if (req.xhr.readyState === 0) {
                Strophe.debug("request id " + req.id + "." + req.sends + " posting");
                req.date = new Date();
                try {
                    req.xhr.open("POST", this.service, true)
                } catch (e2) {
                    Strophe.error("XHR open failed.");
                    if (!this.connected) {
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, "bad-service")
                    }
                    this.disconnect();
                    return
                }
                var sendFunc = function() {
                    req.xhr.send(req.data)
                };
                if (req.sends > 1) {
                    var backoff = Math.pow(req.sends, 3) * 1000;
                    setTimeout(sendFunc, backoff)
                } else {
                    sendFunc()
                }
                req.sends++;
                this.xmlOutput(req.xmlData);
                this.rawOutput(req.data)
            } else {
                Strophe.debug("_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState)
            }
        },
        _throttledRequestHandler: function() {
            if (!this._requests) {
                Strophe.debug("_throttledRequestHandler called with undefined requests")
            } else {
                Strophe.debug("_throttledRequestHandler called with " + this._requests.length + " requests")
            }
            if (!this._requests || this._requests.length === 0) {
                return
            }
            if (this._requests.length > 0) {
                this._processRequest(0)
            }
            if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window - 1) {
                this._processRequest(1)
            }
        },
        _onRequestStateChange: function(func, req) {
            Strophe.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
            if (req.abort) {
                req.abort = false;
                return
            }
            var reqStatus;
            if (req.xhr.readyState == 4) {
                reqStatus = 0;
                try {
                    reqStatus = req.xhr.status
                } catch (e) {}
                if (typeof(reqStatus) == "undefined") {
                    reqStatus = 0
                }
                if (this.disconnecting) {
                    if (reqStatus >= 400) {
                        this._hitError(reqStatus);
                        return
                    }
                }
                var reqIs0 = (this._requests[0] == req);
                var reqIs1 = (this._requests[1] == req);
                if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                    this._removeRequest(req);
                    Strophe.debug("request id " + req.id + " should now be removed")
                }
                if (reqStatus == 200) {
                    if (reqIs1 || (reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                        this._restartRequest(0)
                    }
                    Strophe.debug("request id " + req.id + "." + req.sends + " got 200");
                    func(req);
                    this.errors = 0
                } else {
                    Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
                    if (reqStatus === 0 || (reqStatus >= 400 && reqStatus < 600) || reqStatus >= 12000) {
                        this._hitError(reqStatus);
                        if (reqStatus >= 400 && reqStatus < 500) {
                            this._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                            this._doDisconnect()
                        }
                    }
                }
                if (!((reqStatus > 0 && reqStatus < 10000) || req.sends > 5)) {
                    this._throttledRequestHandler()
                }
            }
        },
        _hitError: function(reqStatus) {
            this.errors++;
            Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
            if (this.errors > 4) {
                this._onDisconnectTimeout()
            }
        },
        _doDisconnect: function() {
            Strophe.info("_doDisconnect was called");
            this.authenticated = false;
            this.disconnecting = false;
            this.sid = null;
            this.streamId = null;
            this.rid = Math.floor(Math.random() * 4294967295);
            if (this.connected) {
                this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
                this.connected = false
            }
            this.handlers = [];
            this.timedHandlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = []
        },
        _dataRecv: function(req) {
            try {
                var elem = req.getResponse()
            } catch (e) {
                if (e != "parsererror") {
                    throw e
                }
                this.disconnect("strophe-parsererror")
            }
            if (elem === null) {
                return
            }
            this.xmlInput(elem);
            this.rawInput(Strophe.serialize(elem));
            var i, hand;
            while (this.removeHandlers.length > 0) {
                hand = this.removeHandlers.pop();
                i = this.handlers.indexOf(hand);
                if (i >= 0) {
                    this.handlers.splice(i, 1)
                }
            }
            while (this.addHandlers.length > 0) {
                this.handlers.push(this.addHandlers.pop())
            }
            if (this.disconnecting && this._requests.length === 0) {
                this.deleteTimedHandler(this._disconnectTimeout);
                this._disconnectTimeout = null;
                this._doDisconnect();
                return
            }
            var typ = elem.getAttribute("type");
            var cond, conflict;
            if (typ !== null && typ == "terminate") {
                cond = elem.getAttribute("condition");
                conflict = elem.getElementsByTagName("conflict");
                if (cond !== null) {
                    if (cond == "remote-stream-error" && conflict.length > 0) {
                        cond = "conflict"
                    }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
                } else {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
                }
                this.disconnect();
                return
            }
            var self = this;
            Strophe.forEachChild(elem, null, function(child) {
                var i, newList;
                newList = self.handlers;
                self.handlers = [];
                for (i = 0; i < newList.length; i++) {
                    var hand = newList[i];
                    if (hand.isMatch(child) && (self.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            self.handlers.push(hand)
                        }
                    } else {
                        self.handlers.push(hand)
                    }
                }
            })
        },
        _sendTerminate: function() {
            Strophe.info("_sendTerminate was called");
            var body = this._buildBody().attrs({
                type: "terminate"
            });
            if (this.authenticated) {
                body.c("presence", {
                    xmlns: Strophe.NS.CLIENT,
                    type: "unavailable"
                })
            }
            this.disconnecting = true;
            var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this).prependArg(this._dataRecv.bind(this)), body.tree().getAttribute("rid"));
            this._requests.push(req);
            this._throttledRequestHandler()
        },
        _connect_cb: function(req) {
            Strophe.info("_connect_cb was called");
            this.connected = true;
            var bodyWrap = req.getResponse();
            if (!bodyWrap) {
                return
            }
            this.xmlInput(bodyWrap);
            this.rawInput(Strophe.serialize(bodyWrap));
            var typ = bodyWrap.getAttribute("type");
            var cond, conflict;
            if (typ !== null && typ == "terminate") {
                cond = bodyWrap.getAttribute("condition");
                conflict = bodyWrap.getElementsByTagName("conflict");
                if (cond !== null) {
                    if (cond == "remote-stream-error" && conflict.length > 0) {
                        cond = "conflict"
                    }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
                } else {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
                }
                return
            }
            if (!this.sid) {
                this.sid = bodyWrap.getAttribute("sid")
            }
            if (!this.stream_id) {
                this.stream_id = bodyWrap.getAttribute("authid")
            }
            var wind = bodyWrap.getAttribute("requests");
            if (wind) {
                this.window = parseInt(wind, 10)
            }
            var hold = bodyWrap.getAttribute("hold");
            if (hold) {
                this.hold = parseInt(hold, 10)
            }
            var wait = bodyWrap.getAttribute("wait");
            if (wait) {
                this.wait = parseInt(wait, 10)
            }
            var do_sasl_plain = false;
            var do_sasl_digest_md5 = false;
            var do_sasl_anonymous = false;
            var mechanisms = bodyWrap.getElementsByTagName("mechanism");
            var i, mech, auth_str, hashed_auth_str;
            if (mechanisms.length > 0) {
                for (i = 0; i < mechanisms.length; i++) {
                    mech = Strophe.getText(mechanisms[i]);
                    if (mech == "DIGEST-MD5") {
                        do_sasl_digest_md5 = true
                    } else {
                        if (mech == "PLAIN") {
                            do_sasl_plain = true
                        } else {
                            if (mech == "ANONYMOUS") {
                                do_sasl_anonymous = true
                            }
                        }
                    }
                }
            } else {
                var body = this._buildBody();
                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this).prependArg(this._connect_cb.bind(this)), body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
                return
            }
            if (Strophe.getNodeFromJid(this.jid) === null && do_sasl_anonymous) {
                this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
                this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
                this.send($build("auth", {
                    xmlns: Strophe.NS.SASL,
                    mechanism: "ANONYMOUS"
                }).tree())
            } else {
                if (Strophe.getNodeFromJid(this.jid) === null) {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, "x-strophe-bad-non-anon-jid");
                    this.disconnect()
                } else {
                    if (do_sasl_digest_md5) {
                        this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                        this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge1_cb.bind(this), null, "challenge", null, null);
                        this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
                        this.send($build("auth", {
                            xmlns: Strophe.NS.SASL,
                            mechanism: "DIGEST-MD5"
                        }).tree())
                    } else {
                        if (do_sasl_plain) {
                            auth_str = Strophe.getBareJidFromJid(this.jid);
                            auth_str = auth_str + "\u0000";
                            auth_str = auth_str + Strophe.getNodeFromJid(this.jid);
                            auth_str = auth_str + "\u0000";
                            auth_str = auth_str + this.pass;
                            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
                            this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
                            hashed_auth_str = Base64.encode(auth_str);
                            this.send($build("auth", {
                                xmlns: Strophe.NS.SASL,
                                mechanism: "PLAIN"
                            }).t(hashed_auth_str).tree())
                        } else {
                            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                            this._addSysHandler(this._auth1_cb.bind(this), null, null, null, "_auth_1");
                            this.send($iq({
                                type: "get",
                                to: this.domain,
                                id: "_auth_1"
                            }).c("query", {
                                xmlns: Strophe.NS.AUTH
                            }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree())
                        }
                    }
                }
            }
        },
        _sasl_challenge1_cb: function(elem) {
            var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
            var challenge = Base64.decode(Strophe.getText(elem));
            var cnonce = MD5.hexdigest(Math.random() * 1234567890);
            var realm = "";
            var host = null;
            var nonce = "";
            var qop = "";
            var matches;
            this.deleteHandler(this._sasl_failure_handler);
            while (challenge.match(attribMatch)) {
                matches = challenge.match(attribMatch);
                challenge = challenge.replace(matches[0], "");
                matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
                switch (matches[1]) {
                    case "realm":
                        realm = matches[2];
                        break;
                    case "nonce":
                        nonce = matches[2];
                        break;
                    case "qop":
                        qop = matches[2];
                        break;
                    case "host":
                        host = matches[2];
                        break
                }
            }
            var digest_uri = "xmpp/" + this.domain;
            if (host !== null) {
                digest_uri = digest_uri + "/" + host
            }
            var A1 = MD5.hash(Strophe.getNodeFromJid(this.jid) + ":" + realm + ":" + this.pass) + ":" + nonce + ":" + cnonce;
            var A2 = "AUTHENTICATE:" + digest_uri;
            var responseText = "";
            responseText += "username=" + this._quote(Strophe.getNodeFromJid(this.jid)) + ",";
            responseText += "realm=" + this._quote(realm) + ",";
            responseText += "nonce=" + this._quote(nonce) + ",";
            responseText += "cnonce=" + this._quote(cnonce) + ",";
            responseText += 'nc="00000001",';
            responseText += 'qop="auth",';
            responseText += "digest-uri=" + this._quote(digest_uri) + ",";
            responseText += "response=" + this._quote(MD5.hexdigest(MD5.hexdigest(A1) + ":" + nonce + ":00000001:" + cnonce + ":auth:" + MD5.hexdigest(A2))) + ",";
            responseText += 'charset="utf-8"';
            this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge2_cb.bind(this), null, "challenge", null, null);
            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
            this.send($build("response", {
                xmlns: Strophe.NS.SASL
            }).t(Base64.encode(responseText)).tree());
            return false
        },
        _quote: function(str) {
            return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
        },
        _sasl_challenge2_cb: function(elem) {
            this.deleteHandler(this._sasl_success_handler);
            this.deleteHandler(this._sasl_failure_handler);
            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
            this.send($build("response", {
                xmlns: Strophe.NS.SASL
            }).tree());
            return false
        },
        _auth1_cb: function(elem) {
            var iq = $iq({
                type: "set",
                id: "_auth_2"
            }).c("query", {
                xmlns: Strophe.NS.AUTH
            }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
            if (!Strophe.getResourceFromJid(this.jid)) {
                this.jid = Strophe.getBareJidFromJid(this.jid) + "/strophe"
            }
            iq.up().c("resource", {}).t(Strophe.getResourceFromJid(this.jid));
            this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
            this.send(iq.tree());
            return false
        },
        _sasl_success_cb: function(elem) {
            Strophe.info("SASL authentication succeeded.");
            this.deleteHandler(this._sasl_failure_handler);
            this._sasl_failure_handler = null;
            if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null
            }
            this._addSysHandler(this._sasl_auth1_cb.bind(this), null, "stream:features", null, null);
            this._sendRestart();
            return false
        },
        _sasl_auth1_cb: function(elem) {
            var i, child;
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                if (child.nodeName == "bind") {
                    this.do_bind = true
                }
                if (child.nodeName == "session") {
                    this.do_session = true
                }
            }
            if (!this.do_bind) {
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false
            } else {
                this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, "_bind_auth_2");
                var resource = Strophe.getResourceFromJid(this.jid);
                if (resource) {
                    this.send($iq({
                        type: "set",
                        id: "_bind_auth_2"
                    }).c("bind", {
                        xmlns: Strophe.NS.BIND
                    }).c("resource", {}).t(resource).tree())
                } else {
                    this.send($iq({
                        type: "set",
                        id: "_bind_auth_2"
                    }).c("bind", {
                        xmlns: Strophe.NS.BIND
                    }).tree())
                }
            }
            return false
        },
        _sasl_bind_cb: function(elem) {
            if (elem.getAttribute("type") == "error") {
                Strophe.info("SASL binding failed.");
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false
            }
            var bind = elem.getElementsByTagName("bind");
            var jidNode;
            if (bind.length > 0) {
                jidNode = bind[0].getElementsByTagName("jid");
                if (jidNode.length > 0) {
                    this.jid = Strophe.getText(jidNode[0]);
                    if (this.do_session) {
                        this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, "_session_auth_2");
                        this.send($iq({
                            type: "set",
                            id: "_session_auth_2"
                        }).c("session", {
                            xmlns: Strophe.NS.SESSION
                        }).tree())
                    } else {
                        this.authenticated = true;
                        this._changeConnectStatus(Strophe.Status.CONNECTED, null)
                    }
                }
            } else {
                Strophe.info("SASL binding failed.");
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false
            }
        },
        _sasl_session_cb: function(elem) {
            if (elem.getAttribute("type") == "result") {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null)
            } else {
                if (elem.getAttribute("type") == "error") {
                    Strophe.info("Session creation failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false
                }
            }
            return false
        },
        _sasl_failure_cb: function(elem) {
            if (this._sasl_success_handler) {
                this.deleteHandler(this._sasl_success_handler);
                this._sasl_success_handler = null
            }
            if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null
            }
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
        },
        _auth2_cb: function(elem) {
            if (elem.getAttribute("type") == "result") {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null)
            } else {
                if (elem.getAttribute("type") == "error") {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    this.disconnect()
                }
            }
            return false
        },
        _addSysTimedHandler: function(period, handler) {
            var thand = new Strophe.TimedHandler(period, handler);
            thand.user = false;
            this.addTimeds.push(thand);
            return thand
        },
        _addSysHandler: function(handler, ns, name, type, id) {
            var hand = new Strophe.Handler(handler, ns, name, type, id);
            hand.user = false;
            this.addHandlers.push(hand);
            return hand
        },
        _onDisconnectTimeout: function() {
            Strophe.info("_onDisconnectTimeout was called");
            var req;
            while (this._requests.length > 0) {
                req = this._requests.pop();
                req.abort = true;
                req.xhr.abort();
                req.xhr.onreadystatechange = function() {}
            }
            this._doDisconnect();
            return false
        },
        _onIdle: function() {
            var i, thand, since, newList;
            while (this.removeTimeds.length > 0) {
                thand = this.removeTimeds.pop();
                i = this.timedHandlers.indexOf(thand);
                if (i >= 0) {
                    this.timedHandlers.splice(i, 1)
                }
            }
            while (this.addTimeds.length > 0) {
                this.timedHandlers.push(this.addTimeds.pop())
            }
            var now = new Date().getTime();
            newList = [];
            for (i = 0; i < this.timedHandlers.length; i++) {
                thand = this.timedHandlers[i];
                if (this.authenticated || !thand.user) {
                    since = thand.lastCalled + thand.period;
                    if (since - now <= 0) {
                        if (thand.run()) {
                            newList.push(thand)
                        }
                    } else {
                        newList.push(thand)
                    }
                }
            }
            this.timedHandlers = newList;
            var body, time_elapsed;
            if (this.authenticated && this._requests.length === 0 && this._data.length === 0 && !this.disconnecting) {
                Strophe.info("no requests during idle cycle, sending blank request");
                this._data.push(null)
            }
            if (this._requests.length < 2 && this._data.length > 0 && !this.paused) {
                body = this._buildBody();
                for (i = 0; i < this._data.length; i++) {
                    if (this._data[i] !== null) {
                        if (this._data[i] === "restart") {
                            body.attrs({
                                to: this.domain,
                                "xml:lang": "en",
                                "xmpp:restart": "true",
                                "xmlns:xmpp": Strophe.NS.BOSH
                            })
                        } else {
                            body.cnode(this._data[i]).up()
                        }
                    }
                }
                delete this._data;
                this._data = [];
                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this).prependArg(this._dataRecv.bind(this)), body.tree().getAttribute("rid")));
                this._processRequest(this._requests.length - 1)
            }
            if (this._requests.length > 0) {
                time_elapsed = this._requests[0].age();
                if (this._requests[0].dead !== null) {
                    if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                        this._throttledRequestHandler()
                    }
                }
                if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                    Strophe.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) + " seconds since last activity");
                    this._throttledRequestHandler()
                }
            }
            clearTimeout(this._idleTimeout);
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100)
        }
    };
    if (callback) {
        callback(Strophe, $build, $msg, $iq, $pres)
    }
})(function() {
    window.Strophe = arguments[0];
    window.$build = arguments[1];
    window.$msg = arguments[2];
    window.$iq = arguments[3];
    window.$pres = arguments[4]
});
g_cb_user = null;
g_cb_roster_items = null;
g_cb_userinfos = null;
g_cb_play_sound = true;
g_cb_is_connected = false;
g_cb_startchat = null;
ChatBar = {
    BOSH_SERVICE: '/http-bind/',
    DOMAIN: 'chat.yooco.de',
    RESOURCE: 'chatbar',
    INACTIVITY_PERIOD_LENGTH: 60,
    NS: {
        CHAT_STATES: 'http://jabber.org/protocol/chatstates'
    },
    Message: {
        Types: {
            NORMAL: 'normal',
            CHAT: 'chat',
            GROUPCHAT: 'groupchat',
            HEADLINE: 'headline',
            ERROR: 'error'
        },
        ChatStates: {
            COMPOSING: 'composing',
            PAUSED: 'paused',
            ACTIVE: 'active',
            INACTIVE: 'inactive',
            GONE: 'gone'
        }
    },
    IQ: {
        Types: {
            GET: 'get',
            RESULT: 'result',
            SET: 'set',
            ERROR: 'error'
        }
    },
    Presence: {
        Types: {
            UNAVAILABLE: 'unavailable',
            SUBSCRIBE: 'subscribe',
            SUBSCRIBED: 'subscribed',
            UNSUBSCRIBE: 'unsubscribe',
            UNSUBSCRIBED: 'unsubscribed',
            PROBE: 'probe',
            ERROR: 'error'
        },
        ChildElements: {
            SHOW: 'show',
            STATUS: 'status',
            PRIORITY: 'priority'
        },
        ShowElements: {
            CHAT: 'chat',
            DND: 'dnd',
            AWAY: 'away',
            XA: 'xa'
        }
    },
    Roster: {
        DEFAULT_GROUP: 'Contacts'
    },
    Events: {
        Identifiers: {
            UPDATE_CONNECTION_STATE: 0,
            UPDATE_ROSTER: 1,
            RECV_PRESENCE: 2,
            RECV_CHAT_MESSAGE: 3
        },
        Messages: {
            ConnectionStates: {
                CONNECTING: "Connecting...",
                AUTHENTICATING: "Logging in...",
                FAILED: "Login failed!",
                DISCONNECTING: "Logging out...",
                OFFLINE: "Offline",
                ONLINE: "Online"
            }
        }
    }
};
ChatBar.Core = {
    ReferenceTables: {
        AvailabilityRates: {
            AVAILABLE: 0,
            ONLINE: 0,
            CHAT: 0,
            DND: 1,
            AWAY: 2,
            XA: 3,
            UNAVAILABLE: 10,
            OFFLINE: 10
        }
    }
};
ChatBar.Core.User = function(jid) {
    if (!(this instanceof arguments.callee))
        return new ChatBar.Core.User(jid);
    var _connection = null;
    var _attached = false;
    var _initialized = false;
    var _jid = null;
    var _roster = null;
    var _msgTemp = [];
    var _funcs = [];
    this.init = function(jid) {
        _jid = jid;
        _roster = new ChatBar.Core.Roster();
    }
    this.getConnection = function() {
        return _connection;
    }
    this.getJid = function() {
        return _jid;
    }
    this.getRoster = function() {
        return _roster;
    }
    this.isAttached = function() {
        return _attached;
    }
    this.isInitialized = function() {
        return _initialized;
    }
    this.setInitialized = function(isInitialized) {
        _initialized = isInitialized;
    }
    this.addObserver = function(eventType, pFunc) {
        if (jQuery.inArray(pFunc, _funcs) == -1) {
            if (!_funcs[eventType])
                _funcs[eventType] = [];
            _funcs[eventType].push(pFunc);
        }
    }
    this.removeObserver = function(pFunc) {
        var index = null;
        for (var key in _funcs) {
            if (typeof _funcs[key] != 'object')
                continue;
            if ((index = jQuery.inArray(pFunc, _funcs[key])) != -1)
                _funcs.splice(index, 1);
        }
    }
    this.connect = function(password) {
        if (_connection == null)
            _connection = new Strophe.Connection(ChatBar.BOSH_SERVICE);
        _connection.connect(_jid, password, _onConnect);
    }
    this.attach = function(sid, rid) {
        if (_connection == null) {
            _connection = new Strophe.Connection(ChatBar.BOSH_SERVICE);
        }
        _connection.attach(_jid, sid, rid, _onConnect);
        _attached = true;
        _onConnect(Strophe.Status.CONNECTED);
    }
    this.disconnect = function() {
        if (_connection != null) {
            _connection.disconnect();
            _connection = null;
        }
    }
    this.requestSessionPause = function() {
        var req = $build('body', {
            rid: _connection.rid,
            sid: _connection.sid,
            pause: ChatBar.INACTIVITY_PERIOD_LENGTH,
            xmlns: Strophe.NS.HTTPBIND
        });
        _attached = false;
        _connection.send(req.tree());
    }
    this.requestRoster = function() {
        var req = $iq({
            from: _jid,
            type: ChatBar.IQ.Types.GET
        }).c('query', {
            xmlns: Strophe.NS.ROSTER
        });
        _connection.send(req.tree());
    }
    this.sendInitialPresence = function() {
        _connection.send($pres().tree());
        _initialized = true;
    }
    this.sendChatMessage = function(addressee, msg) {
        var req = $msg({
            type: ChatBar.Message.Types.CHAT,
            to: addressee,
            from: _connection.jid
        }).c('body').t(msg).up().c(ChatBar.Message.ChatStates.ACTIVE, {
            xmlns: ChatBar.NS.CHAT_STATES
        });
        _connection.send(req.tree());
    }
    this.sendChatStateMessage = function(addressee, state) {
        var req = $msg({
            type: ChatBar.Message.Types.CHAT,
            to: addressee,
            from: _connection.jid
        }).c(state, {
            xmlns: ChatBar.NS.CHAT_STATES
        });
        _connection.send(req.tree());
    }
    this.sendPresenceAvailability = function(availability, details) {
        var req = $pres().c(ChatBar.Presence.ChildElements.SHOW).t(availability).up().c(ChatBar.Presence.ChildElements.STATUS).t(details).up().c(ChatBar.Presence.ChildElements.PRIORITY).t('1');
        _connection.send(req.tree());
    }

    function _fire(eventType, data, scope) {
        if (_funcs[eventType] != undefined) {
            for (var i = 0; i < _funcs[eventType].length; i++)
                _funcs[eventType][i].call((scope || window), data);
        }
    }

    function _onConnect(status) {
        var msg = null;
        if (status == Strophe.Status.CONNECTING) {
            msg = ChatBar.Events.Messages.ConnectionStates.CONNECTING;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.AUTHENTICATING) {
            msg = ChatBar.Events.Messages.ConnectionStates.AUTHENTICATING;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.AUTHFAIL) {
            msg = ChatBar.Events.Messages.ConnectionStates.FAILED;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.CONNFAIL) {
            msg = ChatBar.Events.Messages.ConnectionStates.FAILED;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.DISCONNECTING) {
            msg = ChatBar.Events.Messages.ConnectionStates.DISCONNECTING;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.DISCONNECTED) {
            msg = ChatBar.Events.Messages.ConnectionStates.OFFLINE;
            g_cb_is_connected = false;
        } else if (status == Strophe.Status.CONNECTED) {
            msg = ChatBar.Events.Messages.ConnectionStates.ONLINE;
            _connection.addHandler(_onIQResult, null, 'iq', ChatBar.IQ.Types.RESULT, null, null);
            _connection.addHandler(_onPresence, null, 'presence', null, null, null);
            _connection.addHandler(_onMessageChat, null, 'message', ChatBar.Message.Types.CHAT, null, null);
            g_cb_is_connected = true;
            if (g_cb_startchat != null) {
                ChatBar.UI.Utils.startChat(g_cb_startchat);
                g_cb_startchat = null;
            }
            jQuery.jStorage.set('cb_no_autoconnect', '0');
        }
        _fire(ChatBar.Events.Identifiers.UPDATE_CONNECTION_STATE, msg);
    }

    function _onIQResult(iq) {
        _roster.updateFromIQResult(iq);
        _fire(ChatBar.Events.Identifiers.UPDATE_ROSTER, _roster.getItems());
        return true;
    }

    function _onPresence(presence) {
        if (Strophe.getBareJidFromJid(jQuery(presence).attr('from')).toLowerCase() != Strophe.getBareJidFromJid(_jid).toLowerCase()) {
            _roster.updateFromPresence(presence);
        }
        _fire(ChatBar.Events.Identifiers.RECV_PRESENCE, _roster.getOnlineItems());
        return true;
    }

    function _onMessageChat(message) {
        var data = {
            contactBareJid: Strophe.getBareJidFromJid(jQuery(message).attr('from')),
            msg: message
        };
        _msgTemp.push(data);
        if (_initialized == true) {
            for (var key in _msgTemp) {
                if (typeof _msgTemp[key] != 'object')
                    continue;
                _fire(ChatBar.Events.Identifiers.RECV_CHAT_MESSAGE, _msgTemp[key]);
                _msgTemp.shift();
            }
        }
        return true;
    }
    this.init(jid);
};
ChatBar.Core.Roster = function() {
    if (!(this instanceof arguments.callee))
        return new ChatBar.Core.Roster();
    _items = null;
    this.init = function() {
        _items = (arguments.length > 0) ? arguments[0] : {};
    }
    this.getItems = function() {
        return _items;
    }
    this.setItems = function(items) {
        for (var key in items) {
            _items[key] = new ChatBar.Core.RosterItem(items[key]);
        }
    }
    this.setIcons = function(icons) {
        for (var key in icons) {
            if (_items != null && _items[key]) {
                _items[key].icon_tiny = icons[key].tiny;
            }
        }
    }
    this.setStatuses = function(statuses) {
        for (var key in statuses) {
            if (_items != null && _items[key]) {
                _items[key].status = statuses[key].status;
            }
        }
    }
    this.updateFromIQResult = function(iq) {
        jQuery(iq).find('item').each(function() {
            var attr = {
                bareJid: Strophe.getBareJidFromJid(jQuery(this).attr('jid')).toLowerCase(),
                name: jQuery(this).attr('name'),
                subscription: jQuery(this).attr('subscription'),
                groups: [],
                presences: {}
            };
            jQuery(this).find('group').each(function() {
                attr['groups'].push(jQuery(this).text());
            });
            if (attr['groups'].length == 0)
                attr['groups'].push(ChatBar.Roster.DEFAULT_GROUP);
            if (!_items[attr.bareJid])
                _items[attr.bareJid] = new ChatBar.Core.RosterItem(attr);
            else {
                _items[attr.bareJid].bareJid = attr.bareJid;
                _items[attr.bareJid].name = attr.name;
                _items[attr.bareJid].subscription = attr.subscription;
                _items[attr.bareJid].groups = attr.groups;
            }
        });
    }
    this.updateFromPresence = function(presence) {
        var jid = jQuery(presence).attr('from').toLowerCase();
        var attr = {
            bareJid: Strophe.getBareJidFromJid(jid),
            name: null,
            subscription: null,
            groups: null,
            presences: {}
        };
        attr.presences[jid] = {};
        attr.presences[jid].type = (!jQuery(presence).attr('type')) ? 'available' : jQuery(presence).attr('type');
        if (attr.presences[jid].type == 'available') {
            jQuery(presence).children().each(function() {
                if (this.tagName == ChatBar.Presence.ChildElements.SHOW)
                    attr.presences[jid].show = jQuery(this).text();
                if (this.tagName == ChatBar.Presence.ChildElements.STATUS)
                    attr.presences[jid].status = jQuery(this).text();
            });
            if (!attr.presences[jid].show)
                attr.presences[jid].show = 'chat';
        } else {
            attr.presences[jid].show = 'offline';
        }
        if (!_items[attr.bareJid])
            _items[attr.bareJid] = new ChatBar.Core.RosterItem(attr);
        else
            _items[attr.bareJid].presences[jid] = attr.presences[jid];
    }
    this.getOnlineItems = function() {
        var sortedOnlineBareJid = [];
        var sortedOnlineItems = {};
        var last = 0;
        var count = 0;
        for (var key in _items) {
            if (typeof _items[key] != 'object')
                continue;
            var pres = _items[key].getStrongestPresence();
            if (pres != null && pres.type == 'available') {
                sortedOnlineBareJid.push(key);
            }
            count = count + 1;
        }
        if (sortedOnlineBareJid.length > 1) {
            sortedOnlineBareJid.sort();
            sortedOnlineBareJid.sort(statusSort);
        }
        for (var key in sortedOnlineBareJid) {
            sortedOnlineItems[sortedOnlineBareJid[key]] = _items[sortedOnlineBareJid[key]];
            last = sortedOnlineBareJid[key];
        }
        if (count < 60) {
            for (var key in _items) {
                if (!sortedOnlineBareJid[key] && !sortedOnlineItems[key] && g_cb_roster_items[key]) {
                    sortedOnlineItems[key] = _items[key];
                }
            }
        }
        return (sortedOnlineItems);
    }
    this.getSizeOnlineItems = function() {
        var n = 0;
        for (var key in _items) {
            if (typeof _items[key] != 'object')
                continue;
            var pres = _items[key].getStrongestPresence();
            if (pres != null && pres.type == 'available')
                ++n;
        }
        return (n);
    }
    this.getItemsUsernamesAsList = function() {
        var data = '';
        for (var key in _items) {
            if (typeof _items[key] != 'object')
                continue;
            data = data + Strophe.getNodeFromJid(key) + ',';
        }
        return (data);
    }

    function statusSort(x, y) {
        var xPres = _items[x].getStrongestPresence();
        var yPres = _items[y].getStrongestPresence();
        if (xPres != null && yPres != null)
            return (ChatBar.Core.Roster.Utils.comparePresences(xPres, yPres));
        return (0);
    }
    this.init();
};
ChatBar.Core.Roster.Utils = {
    comparePresences: function(xPres, yPres) {
        var xRate = 0;
        var yRate = 0;
        if (xPres.type == 'unavailable')
            xRate += ChatBar.Core.ReferenceTables.AvailabilityRates[xPres.type.toUpperCase()];
        if (yPres.type == 'unavailable')
            yRate += ChatBar.Core.ReferenceTables.AvailabilityRates[yPres.type.toUpperCase()];
        if (xPres.show != null)
            xRate += ChatBar.Core.ReferenceTables.AvailabilityRates[xPres.show.toUpperCase()];
        if (yPres.show != null)
            yRate = +ChatBar.Core.ReferenceTables.AvailabilityRates[yPres.show.toUpperCase()];
        if (xRate > yRate)
            return (1);
        else if (xRate == yRate)
            return (0);
        return (-1);
    }
};
ChatBar.Core.RosterItem = function() {
    this.bareJid = (arguments.length > 0) ? arguments[0].bareJid : null;
    this.name = (arguments.length > 0) ? arguments[0].name : null;
    this.subscription = (arguments.length > 0) ? arguments[0].subscription : null;
    this.groups = (arguments.length > 0) ? arguments[0].groups : null;
    this.presences = (arguments.length > 0) ? arguments[0].presences : null;
    this.icon_tiny = (arguments.length > 0) ? arguments[0].icon_tiny : null;
    this.status = (arguments.length > 0) ? arguments[0].status : null;
};
ChatBar.Core.RosterItem.prototype = {
    getStrongestPresence: function() {
        var res = {
            type: 'offline',
            show: 'offline',
            status: ''
        };
        for (var key in this.presences) {
            if (typeof this.presences[key] != 'object')
                continue;
            if (res == null)
                res = this.presences[key];
            else
            if (ChatBar.Core.Roster.Utils.comparePresences(this.presences[key], res) == -1)
                res = this.presences[key];
        }
        return (res);
    }
};
ChatBar.UI = {
    HAS_FOCUS: true,
    Resources: {
        Paths: {
            ICONS: '/templates/core/images/chatbar/',
            MEMBER_PROFILE: '/profile/'
        },
        Emoticons: {
            FILENAME_SMILE: 'emoticon_smile.png',
            FILENAME_UNHAPPY: 'emoticon_unhappy.png',
            FILENAME_GRIN: 'emoticon_grin.png',
            FILENAME_EVILGRIN: 'emoticon_evilgrin.png',
            FILENAME_SURPRISED: 'emoticon_surprised.png',
            FILENAME_TONGUE: 'emoticon_tongue.png',
            FILENAME_WINK: 'emoticon_wink.png'
        },
        Strings: {
            Availability: {
                AVAILABLE: "Verfuegbar",
                CHAT: "Verfuegbar",
                ONLINE: "Verfuegbar",
                DND: "Beschaeftigt",
                AWAY: "Abwesend",
                XA: "Nicht verfuegbar",
                OFFLINE: "Offline"
            },
            Contacts: {
                BUTTON: "Chat"
            },
            ChatMessages: {
                SELF: "christian",
                COMPOSING: " schreibt..."
            },
            Box: {
                MINIMIZE: "Minimieren",
                CLOSE: "Schliessen",
                SHOWHIDE: "Anzeigen / Ausblenden"
            }
        },
        StyleClasses: {
            Availability: {
                Left: {
                    ONLINE: 'cb_left_availability_chat',
                    DND: 'cb_left_availability_dnd',
                    AWAY: 'cb_left_availability_away',
                    XA: 'cb_left_availability_xa',
                    OFFLINE: 'cb_left_availability_offline'
                },
                Right: {
                    ONLINE: 'cb_right_availability_chat',
                    DND: 'cb_right_availability_dnd',
                    AWAY: 'cb_right_availability_away',
                    XA: 'cb_right_availability_xa',
                    OFFLINE: 'cb_right_availability_offline'
                },
                Control: {
                    UP: 'cb_availability_switcher_control_up',
                    DOWN: 'cb_availability_switcher_control_down'
                }
            },
            ChatBox: {
                MAIN: 'cb_chatbox',
                TOP: 'cb_chatbox_top',
                SUBTOP: 'cb_chatbox_subtop',
                TOP_ICON: 'cb_chatbox_top_icon',
                TOP_CONTROLS: 'cb_chatbox_top_controls',
                CONTENT: 'cb_chatbox_content',
                INPUT: 'cb_chatbox_input',
                BOTTOM: 'cb_chatbox_bottom',
                CONTROL: 'cb_chatbox_control',
                STATE: 'cb_chatbox_state',
                MESSAGE: 'cb_chatbox_message',
                MESSAGE_SENDER: 'cb_chatbox_message_sender',
                MESSAGE_DATE: 'cb_chatbox_message_date'
            },
            ScrollBox: {
                SELECTED: 'cb_scrollbox_selected'
            },
            BOX_CONTROL: 'cb_box_control',
            LABEL: 'cb_label',
            UNREAD_COUNT: 'cb_unread_count'
        },
        Elements: {
            ID_DIV_BAR: 'cb',
            ID_DIV_BAR_CENTER: 'cb_center',
            ID_DIV_BAR_RIGHT: 'cb_right',
            ID_TOOLTIP_TRIGGER: 'cb_tooltip_trigger',
            ID_SPAN_CONTACTS_BUTTON: 'cb_contacts_button',
            ID_SPAN_CLOSE_BOX: 'cb_box_control_close',
            ID_DIV_CONTACTS: 'cb_contacts',
            ID_DIV_CONTACTS_CONTROLS: 'cb_contacts_controls',
            ID_SPAN_CONTACTS_CONTROL_MINIMIZE: 'cb_contacts_control_minimize',
            ID_SPAN_CONTACTS_CONTROL_AUDIO: 'cb_contacts_control_audio',
            ID_DIV_CONTACTS_CONTENT: 'cb_contacts_content',
            ID_UL_CONTACTS_LIST: 'cb_contacts_list',
            ID_DIV_AVAILABILITY_SWITCHER: 'cb_availability_switcher',
            ID_SPAN_AVAILABILITY_SWITCHER_CONTROL: 'cb_availability_switcher_control',
            ID_SPAN_CURRENT_AVAILABILITY: 'cb_current_availability',
            ID_UL_AVAILABILITY_SWITCHER_LIST: 'cb_availability_switcher_list',
            ID_DIV_CHATBOXES: 'cb_chatboxes',
            ID_DIV_SCROLLBOXES: 'cb_scrollboxes'
        }
    },
    initialize: function(ts, token) {
        this.ts = ts;
        this.token = token;
        jQuery('#accountlinks').find('li').filter('[class=last]').bind('click', function() {
            if (g_cb_user != null)
                g_cb_user.disconnect();
        });
        ChatBar.UI.AvailabilitySwitcher.initialize(ChatBar.Presence.ShowElements.CHAT);
        ChatBar.UI.ContactsList.initialize();
        ChatBar.UI.ScrollBoxes.initialize();
        ChatBar.UI.loadConnection();
    },
    addActionTokens: function(url_string) {
        return url_string + "?" + this.ts + "=" + this.token;
    },
    getUserDetails: function(cb_func) {
        var json = null;
        var self = this;
        jQuery.ajax({
            url: self.addActionTokens('/chatbar/get_details.do'),
            async: true,
            dataType: 'json',
            success: function(data) {
                cb_func(data);
            }
        });
        return (json);
    },
    connect: function() {
        var conn = (arguments.length > 0) ? arguments[0] : null;
        var userDetails = {
            jid: (conn != null) ? conn.jid : null,
            password: null
        }
        var self = this;
        if (conn == null || (conn != null && conn.attached)) {
            ChatBar.UI.getUserDetails(function(retrievedUserDetails) {
                userDetails.jid = retrievedUserDetails.username + '@' + ChatBar.DOMAIN + '/' + ChatBar.RESOURCE;
                userDetails.password = retrievedUserDetails.password;
                self.connect_end(conn, userDetails)
            });
        } else
            this.connect_end(conn, userDetails)
    },
    connect_end: function(conn, userDetails) {
        g_cb_user = new ChatBar.Core.User(userDetails.jid);
        g_cb_user.addObserver(ChatBar.Events.Identifiers.UPDATE_CONNECTION_STATE, ChatBar.UI.updateConnectionStatus);
        g_cb_user.addObserver(ChatBar.Events.Identifiers.UPDATE_ROSTER, ChatBar.UI.onRosterUpdate);
        g_cb_user.addObserver(ChatBar.Events.Identifiers.RECV_PRESENCE, ChatBar.UI.ContactsList.update);
        g_cb_user.addObserver(ChatBar.Events.Identifiers.RECV_CHAT_MESSAGE, ChatBar.UI.onChatMessage);
        if (conn == null || (conn != null && conn.attached))
            g_cb_user.connect(userDetails.password);
        else
            g_cb_user.attach(conn.sid, conn.rid);
    },
    disconnect: function() {
        g_cb_user.disconnect();
    },
    updateConnectionStatus: function(connStatusMsg) {
        ChatBar.UI.ContactsList.updateButtonText(connStatusMsg);
        if (connStatusMsg == ChatBar.Events.Messages.ConnectionStates.ONLINE) {
            if (!g_cb_user.isAttached()) {
                g_cb_user.requestRoster();
                jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_CONTACTS_LIST).show();
                jQuery('.' + ChatBar.UI.Resources.StyleClasses.ChatBox.INPUT + '>textarea').removeAttr('disabled');
            }
            if (g_cb_user.isAttached()) {
                ChatBar.UI.loadState();
            }
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).attr('class', 'online');
            ChatBar.UI.saveConnection();
        } else if (connStatusMsg == ChatBar.Events.Messages.ConnectionStates.OFFLINE) {
            var contactsBoxElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CONTACTS);
            if (!contactsBoxElm.is(':hidden'))
                ChatBar.UI.ContactsList.toggleDisplay();
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_CONTACTS_LIST).empty();
            ChatBar.UI.AvailabilitySwitcher.initialize(ChatBar.Presence.ShowElements.CHAT);
            ChatBar.UI.ContactsList.updateButtonText(ChatBar.UI.Resources.Strings.Contacts.BUTTON);
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).attr('class', 'offline');
            jQuery('.' + ChatBar.UI.Resources.StyleClasses.ChatBox.INPUT + '>textarea').attr('disabled', 'true');
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES).children().hide();
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES).find('ul').children().attr('class', ChatBar.UI.Resources.StyleClasses.LABEL + ' ' + ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[ChatBar.Presence.Types.UNAVAILABLE.toUpperCase()]);
            g_cb_user = null;
            ChatBar.UI.saveConnection();
        }
    },
    saveConnection: function() {
        var conn = null;
        if (g_cb_user != null) {
            var userConn = g_cb_user.getConnection();
            conn = {
                'jid': userConn.jid,
                'sid': userConn.sid,
                'rid': userConn.rid,
                'attached': g_cb_user.isAttached()
            };
        }
        var self = this;
        cb_debug('saving connection...');
        jQuery.jStorage.set("cb_conn_" + g_cb_myid, conn, {
            TTL: 3600000
        });
        cb_debug('saved connection: ' + JSON.stringify(conn));
    },
    loadConnection: function() {
        var self = this;
        cb_debug('loading connection...');
        conn = jQuery.jStorage.get("cb_conn_" + g_cb_myid);
        cb_debug('loaded connection: ' + JSON.stringify(conn));
        if (conn != null && conn.jid) {
            if (conn.attached)
                ChatBar.UI.connect();
            else
                ChatBar.UI.connect(conn);
        } else {
            var cb_no_autoconnect = jQuery.jStorage.get('cb_no_autoconnect');
            if (cb_no_autoconnect != '1')
                ChatBar.UI.connect();
        }
    },
    saveState: function() {
        var self = this;
        var currentAvailabilityClass = jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CURRENT_AVAILABILITY).attr('class');
        var currentAvailability = currentAvailabilityClass.substr(currentAvailabilityClass.lastIndexOf('_') + 1);
        var data = {
            availability: currentAvailability,
            contacts: g_cb_roster_items,
            userinfos: g_cb_userinfos,
            no_sound: !g_cb_play_sound,
            chats: {},
            contacts_list: {
                minimized: jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CONTACTS).is(':hidden')
            }
        };
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES).children().each(function() {
            var contactBareJid = jQuery(this).attr('bareJid');
            data.chats[contactBareJid] = {
                'html_content': jQuery(this).children().filter("[bareJid^='" + contactBareJid + "']").html(),
                'minimized': jQuery(this).is(':hidden'),
                'unread': ChatBar.UI.UnreadCountBox.getElm(contactBareJid).text()
            };
        });
        cb_debug('saving state...');
        jQuery.jStorage.set("cb_state_" + g_cb_myid, data, {
            TTL: 3600000
        });
        cb_debug('saved state: ' + JSON.stringify(data));
    },
    loadState: function() {
        var self = this;
        cb_debug('loading state...');
        json = jQuery.jStorage.get("cb_state_" + g_cb_myid);
        cb_debug('loaded state: ' + JSON.stringify(json));
        if (json != null) {
            ChatBar.UI.AvailabilitySwitcher.initialize(json.availability);
            if (!json.contacts_list.minimized) {
                jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CONTACTS).show();
                ChatBar.UI.ContactsList.showedStyle();
            }
            g_cb_user.getRoster().setItems(json.contacts);
            g_cb_roster_items = g_cb_user.getRoster().getItems();
            ChatBar.UI.ContactsList.update(g_cb_user.getRoster().getOnlineItems());
            g_cb_user.setInitialized(true);
            g_cb_userinfos = json.userinfos;
            if (json.no_sound || jQuery.cookie("cb_no_sound") == '1') {
                g_cb_play_sound = false;
                jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_CONTROL_AUDIO).addClass('off');
            }
            var scrollBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES);
            var scrollBoxElmToShow = null;
            for (var key in json.chats) {
                ChatBar.UI.ScrollBoxes.add(key);
                var chatBoxElm = ChatBar.UI.ChatBoxes.getChatBoxElm(key);
                if (!json.chats[key].minimized) {
                    scrollBoxElmToShow = ChatBar.UI.ScrollBoxes.getScrollBoxElm(key);
                }
                var chatBoxContentElm = chatBoxElm.children().filter("[bareJid^='" + key + "']");
                chatBoxContentElm.append(json.chats[key].html_content);
                chatBoxContentElm.scrollTo('max');
                ChatBar.UI.UnreadCountBox.update(key, json.chats[key].unread);
            }
            if (scrollBoxElmToShow != null)
                scrollBoxesElm.trigger('goto', scrollBoxesElm.find('ul').children().index(scrollBoxElmToShow));
            else
                scrollBoxesElm.trigger('goto', 0);
            g_cb_user.sendPresenceAvailability(json.availability, '');
            ChatBar.UI.ScrollBoxes.isInitialized = true;
            for (var key in json.chats) {
                if (json.chats[key].minimized) {
                    ChatBar.UI.ChatBoxes.getChatBoxElm(key).hide();
                    ChatBar.UI.ScrollBoxes.unselect(key);
                }
            }
        }
    },
    loadRosterItemsIcons: function() {
        var data = g_cb_user.getRoster().getItemsUsernamesAsList();
        var self = this;
        g_cb_user.getRoster().setIcons(g_cb_userinfos);
        g_cb_user.getRoster().setStatuses(g_cb_userinfos);
        g_cb_roster_items = g_cb_user.getRoster().getItems();
    },
    loadRosterItemsStatuses: function() {
        return true;
    },
    onRosterUpdate: function(rosterItems) {
        g_cb_roster_items = rosterItems;
        if (!g_cb_user.isInitialized()) {
            ChatBar.UI.loadRosterItemsIcons();
            ChatBar.UI.loadRosterItemsStatuses();
            g_cb_user.sendInitialPresence();
        }
    },
    onChatMessage: function(data) {
        if (jQuery(data.msg).find('body').length == 0) {
            ChatBar.UI.ChatBoxes.updateChatState(data.contactBareJid, data.msg, false);
        } else {
            var delayDate = false;
            if (jQuery(data.msg).find('delay') && jQuery(data.msg).find('delay').attr('stamp')) {
                var tstamp = jQuery(data.msg).find('delay').attr('stamp');
                if (tstamp != '') {
                    var tmpDelyDate = ChatBar.UI.Utils.parseISO8601(tstamp);
                    if (typeof tmpDelyDate !== 'undefined' && tmpDelyDate !== false && tmpDelyDate != NaN) {
                        delayDate = new Date(tmpDelyDate);
                    } else {
                        delayDate = false;
                    }
                }
            }
            ChatBar.UI.ChatBoxes.update(data.contactBareJid, ChatBar.UI.Utils.getContactName(data.contactBareJid), Strophe.getText(jQuery(data.msg).find('body')[0]), delayDate);
        }
    }
};
ChatBar.UI.Resources.ReferenceTables = {
    Styles: {
        Availability: {
            Left: {
                AVAILABLE: ChatBar.UI.Resources.StyleClasses.Availability.Left.ONLINE,
                CHAT: ChatBar.UI.Resources.StyleClasses.Availability.Left.ONLINE,
                DND: ChatBar.UI.Resources.StyleClasses.Availability.Left.DND,
                AWAY: ChatBar.UI.Resources.StyleClasses.Availability.Left.AWAY,
                XA: ChatBar.UI.Resources.StyleClasses.Availability.Left.XA,
                UNAVAILABLE: ChatBar.UI.Resources.StyleClasses.Availability.Left.OFFLINE,
                OFFLINE: ChatBar.UI.Resources.StyleClasses.Availability.Left.OFFLINE
            },
            Right: {
                AVAILABLE: ChatBar.UI.Resources.StyleClasses.Availability.Right.ONLINE,
                CHAT: ChatBar.UI.Resources.StyleClasses.Availability.Right.ONLINE,
                DND: ChatBar.UI.Resources.StyleClasses.Availability.Right.DND,
                AWAY: ChatBar.UI.Resources.StyleClasses.Availability.Right.AWAY,
                XA: ChatBar.UI.Resources.StyleClasses.Availability.Right.XA,
                UNAVAILABLE: ChatBar.UI.Resources.StyleClasses.Availability.Right.OFFLINE,
                OFFLINE: ChatBar.UI.Resources.StyleClasses.Availability.Right.OFFLINE
            }
        }
    }
};
ChatBar.UI.ContactsList = {
    initialize: function() {
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_CONTROL_MINIMIZE).unbind('click').bind('click', ChatBar.UI.ContactsList.toggleDisplay);
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_CONTROL_AUDIO).unbind('click').bind('click', ChatBar.UI.ContactsList.toggleAudio);
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).unbind('click').bind('click', function() {
            if (g_cb_user == null)
                ChatBar.UI.connect();
            else
                ChatBar.UI.ContactsList.toggleDisplay();
        });
    },
    update: function(onlineRosterItems) {
        var contactsListElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_CONTACTS_LIST);
        contactsListElm.children().each(function() {
            var contactBareJid = jQuery(this).attr('bareJid');
            if (g_cb_roster_items != null) {
                if (jQuery.inArray(contactBareJid, onlineRosterItems) == -1) {
                    ChatBar.UI.ScrollBoxes.updateAvailability(contactBareJid);
                    jQuery(this).remove();
                }
            }
        });
        for (var key in onlineRosterItems) {
            if (typeof onlineRosterItems[key] != 'object' || !onlineRosterItems[key] || typeof g_cb_userinfos[key] === 'undefined' || !g_cb_userinfos[key]) {
                continue;
            }
            var contactElm = contactsListElm.find('li').filter("[bareJid^='" + key + "']");
            if (contactElm.length == 0) {
                contactElm = jQuery('<li></li>').attr('bareJid', key).append(jQuery('<img />').attr('height', '25').attr('src', ChatBar.UI.Utils.getStaticURL(g_cb_userinfos[key].icon_tiny))).append(ChatBar.UI.Utils.getTruncatedContactName(key, 25)).appendTo(contactsListElm).bind('click', function() {
                    if (!ChatBar.UI.ChatBoxes.getChatBoxElm(jQuery(this).attr('bareJid')).is(':visible')) {
                        ChatBar.UI.ContactsList.toggleDisplay();
                    }
                    ChatBar.UI.ScrollBoxes.add(jQuery(this).attr('bareJid'), true);
                });
            }
            ChatBar.UI.ContactsList.updateContactAvailability(contactElm, key);
        }
        ChatBar.UI.ContactsList.updateButtonText(ChatBar.UI.Resources.Strings.Contacts.BUTTON + ' (<strong>' + g_cb_user.getRoster().getSizeOnlineItems() + '</strong>)');
    },
    updateContactAvailability: function(contactElm, contactBareJid) {
        contactElm.attr('class', ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Right[g_cb_roster_items[contactBareJid].getStrongestPresence().show.toUpperCase()]);
        ChatBar.UI.ScrollBoxes.updateAvailability(contactBareJid);
    },
    updateButtonText: function(msg) {
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).html(msg);
    },
    toggleDisplay: function() {
        var contactsBoxElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CONTACTS);
        contactsBoxElm.toggle();
        if (contactsBoxElm.is(':hidden')) {
            ChatBar.UI.ContactsList.hiddenStyle();
        } else {
            ChatBar.UI.ContactsList.showedStyle();
        }
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_AVAILABILITY_SWITCHER_LIST).hide();
    },
    toggleAudio: function() {
        g_cb_play_sound = !g_cb_play_sound;
        if (g_cb_play_sound) {
            jQuery.cookie("cb_no_sound", null);
        } else {
            jQuery.cookie("cb_no_sound", '1', {
                expires: 360
            });
        }
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_CONTROL_AUDIO).toggleClass('off');
    },
    hiddenStyle: function() {
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_BAR_RIGHT).css({
            'border-left': '1px solid #cccccc',
            'border-right': '1px solid #cccccc',
            'background-color': '#eeeeee'
        });
    },
    showedStyle: function() {
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_BAR_RIGHT).css({
            'border-left': '1px solid #999999',
            'border-right': '1px solid #999999',
            'background-color': 'white'
        });
    }
};
ChatBar.UI.AvailabilitySwitcher = {
    initialize: function(availability) {
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_AVAILABILITY_SWITCHER).unbind('click').bind('click', ChatBar.UI.AvailabilitySwitcher.toggleListDisplay);
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_AVAILABILITY_SWITCHER_LIST).find('li').each(function() {
            jQuery(this).unbind('click').bind('click', function() {
                var availabilityClass = jQuery(this).attr('class');
                var availability = availabilityClass.substr(availabilityClass.lastIndexOf('_') + 1);
                if (availability == 'offline') {
                    ChatBar.UI.disconnect();
                    jQuery.jStorage.set('cb_no_autoconnect', '1');
                } else {
                    g_cb_user.sendPresenceAvailability(availability, '');
                    ChatBar.UI.AvailabilitySwitcher.update(availability);
                    jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_AVAILABILITY_SWITCHER_LIST).hide();
                    jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_CONTACTS_LIST).show();
                }
            });
        });
        ChatBar.UI.AvailabilitySwitcher.update(availability);
    },
    update: function(availability) {
        var upperCasedAvailability = availability.toUpperCase();
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CURRENT_AVAILABILITY).attr('class', ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[upperCasedAvailability]).text(ChatBar.UI.Resources.Strings.Availability[upperCasedAvailability]);
        if (availability == 'chat' && g_cb_user != null)
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).attr('class', 'online');
        else if (availability == 'xa' || availability == 'away')
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).attr('class', 'away');
        else if (availability == 'dnd')
            jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_CONTACTS_BUTTON).attr('class', 'dnd');
    },
    switchControlClass: function() {
        var switcherControlElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_SPAN_AVAILABILITY_SWITCHER_CONTROL);
        if (switcherControlElm.attr('class') == ChatBar.UI.Resources.StyleClasses.Availability.Control.UP)
            switcherControlElm.attr('class', ChatBar.UI.Resources.StyleClasses.Availability.Control.DOWN);
        else
            switcherControlElm.attr('class', ChatBar.UI.Resources.StyleClasses.Availability.Control.UP);
    },
    toggleListDisplay: function() {
        ChatBar.UI.AvailabilitySwitcher.switchControlClass();
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_CONTACTS_LIST).toggle();
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_UL_AVAILABILITY_SWITCHER_LIST).toggle();
    }
};
ChatBar.UI.ScrollBoxes = {
    isInitialized: false,
    initialize: function() {
        var $prev = jQuery('#cb_center_prev'),
            $next = jQuery('#cb_center_next');
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_BAR_CENTER).serialScroll({
            target: '#cb_scrollboxes',
            items: 'li',
            prev: '#cb_center_prev',
            next: '#cb_center_next',
            axys: 'x',
            start: 2,
            step: -1,
            interval: 0,
            duration: 0,
            cycle: false,
            force: true,
            jump: true,
            lock: true,
            lazy: true,
            constant: true,
            onBefore: function(e, elem, $pane, $items, pos) {
                $next.add($prev).hide();
                $prev.add($next).hide();
                if (pos != 0) {
                    $next.show();
                }
                if (pos != $items.length - 1)
                    $prev.show();
            },
            onAfter: function(elem) {
                ChatBar.UI.ChatBoxes.takeStand(jQuery(elem).attr('bareJid'));
                ChatBar.UI.ScrollBoxes.isInitialized = true;
            }
        });
    },
    add: function(contactBareJid) {
        var scrollBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES);
        var scrollBoxElm = scrollBoxesElm.find('ul').children().filter("[bareJid^='" + contactBareJid + "']");
        if (scrollBoxElm.length == 0) {
            var availClass = null;
            if (g_cb_roster_items != null && g_cb_roster_items[contactBareJid] != null) {
                var pres = g_cb_roster_items[contactBareJid].getStrongestPresence();
            } else {
                var pres = null;
            }
            if (pres != null)
                availClass = ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[pres.show.toUpperCase()];
            else
                availClass = ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[ChatBar.Presence.Types.UNAVAILABLE.toUpperCase()];
            scrollBoxElm = jQuery('<li></li>').attr('class', ChatBar.UI.Resources.StyleClasses.LABEL + ' ' + availClass).attr('bareJid', contactBareJid).attr('title', ChatBar.UI.Resources.Strings.Box.SHOWHIDE).text(ChatBar.UI.Utils.getTruncatedContactName(contactBareJid, 11)).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.BOX_CONTROL).attr('id', ChatBar.UI.Resources.Elements.ID_SPAN_CLOSE_BOX).text('x').attr('title', ChatBar.UI.Resources.Strings.Box.CLOSE).bind('click', function() {
                var scrollBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES);
                ChatBar.UI.ChatBoxes.remove(jQuery(this).parent().attr('bareJid'));
                scrollBoxesElm.trigger('goto', scrollBoxesElm.find('ul').children().index(ChatBar.UI.ScrollBoxes.getSelectedScrollBoxElm()));
            }));
            scrollBoxesElm.find('ul').append(scrollBoxElm);
            ChatBar.UI.ChatBoxes.add(contactBareJid);
            if (arguments.length == 2 && arguments[1])
                scrollBoxesElm.trigger('goto', scrollBoxesElm.find('ul').children().index(scrollBoxElm));
            ChatBar.UI.loadRosterItemsIcons();
            ChatBar.UI.loadRosterItemsStatuses();
        } else {
            scrollBoxesElm.trigger('goto', scrollBoxesElm.find('ul').children().index(scrollBoxElm));
        }
    },
    remove: function(contactBareJid) {
        ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid).remove();
    },
    unselect: function(contactBareJid) {
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid);
        scrollBoxElm.attr('class', (scrollBoxElm.attr('class')).replace(/cb_scrollbox_selected/, ''));
    },
    select: function(contactBareJid) {
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid);
        var scrollBoxElmClasses = scrollBoxElm.attr('class');
        if (scrollBoxElmClasses.search(/cb_scrollbox_selected/) == -1)
            scrollBoxElm.attr('class', scrollBoxElmClasses + ' ' + ChatBar.UI.Resources.StyleClasses.ScrollBox.SELECTED);
    },
    updateAvailability: function(contactBareJid) {
        var pres = g_cb_roster_items[contactBareJid].getStrongestPresence();
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid);
        var scrollBoxElmClasses = scrollBoxElm.attr('class');
        var updatedAvailability = null;
        if (pres != null)
            updatedAvailability = ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[pres.show.toUpperCase()];
        else
            updatedAvailability = ChatBar.UI.Resources.ReferenceTables.Styles.Availability.Left[ChatBar.Presence.Types.UNAVAILABLE.toUpperCase()];
        if (scrollBoxElmClasses == undefined || scrollBoxElmClasses.search(/(cb_left_availability_)/g) == -1) {
            scrollBoxElm.attr('class', ChatBar.UI.Resources.StyleClasses.LABEL + ' ' + updatedAvailability);
        } else {
            updatedAvailability = updatedAvailability.replace(/(cb_left_availability)/g, '');
            scrollBoxElmClasses = scrollBoxElmClasses.replace(/(_chat)/g, updatedAvailability);
            scrollBoxElmClasses = scrollBoxElmClasses.replace(/(_dnd)/g, updatedAvailability);
            scrollBoxElmClasses = scrollBoxElmClasses.replace(/(_away)/g, updatedAvailability);
            scrollBoxElmClasses = scrollBoxElmClasses.replace(/(_xa)/g, updatedAvailability);
            scrollBoxElmClasses = scrollBoxElmClasses.replace(/(_offline)/g, updatedAvailability);
            scrollBoxElm.attr('class', scrollBoxElmClasses);
        }
    },
    getSelectedScrollBoxElm: function(contactBareJid) {
        var elm = undefined;
        jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES).find('ul').children().each(function() {
            if (jQuery(this).attr('class').search(/cb_scrollbox_selected/) != -1)
                elm = jQuery(this);
        });
        return (elm);
    },
    getScrollBoxElm: function(contactBareJid) {
        return jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES).find('ul').children().filter("[bareJid^='" + contactBareJid + "']");
    }
};
ChatBar.UI.ChatBoxes = {
    dateLastComposing: {},
    lastTimedPauses: {},
    add: function(contactBareJid) {
        var chatBoxes = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES);
        if (jQuery(chatBoxes).children().filter("[bareJid^='" + contactBareJid + "']").length == 0) {
            var chatBox = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.MAIN).attr('bareJid', contactBareJid).hide();
            var chatBoxTop = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.TOP).append(jQuery('<a></a>').attr('href', ChatBar.UI.Resources.Paths.MEMBER_PROFILE + ChatBar.UI.Utils.getTruncatedContactName(contactBareJid) + '.html').append(jQuery('<img />').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.TOP_ICON).attr('height', '53').attr('src', ChatBar.UI.Utils.getContactIcon(contactBareJid)))).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.LABEL).html('<a href="' + ChatBar.UI.Resources.Paths.MEMBER_PROFILE + ChatBar.UI.Utils.getTruncatedContactName(contactBareJid) + '.html">' + ChatBar.UI.Utils.getTruncatedContactName(contactBareJid) + '</a>')).append(jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.TOP_CONTROLS).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.CONTROL).attr('id', ChatBar.UI.Resources.Elements.ID_SPAN_CLOSE_BOX).text('x').attr('title', ChatBar.UI.Resources.Strings.Box.CLOSE).bind('click', function() {
                ChatBar.UI.ChatBoxes.remove(jQuery(this).parent().parent().parent().attr('bareJid'));
            })).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.CONTROL).attr('id', ChatBar.UI.Resources.Elements.ID_SPAN_CLOSE_BOX).text('_').attr('title', ChatBar.UI.Resources.Strings.Box.MINIMIZE).css({
                'font-size': '11px',
                'position': 'relative',
                'line-height': '11px'
            }).bind('click', function() {
                ChatBar.UI.ScrollBoxes.unselect(jQuery(this).parent().parent().parent().attr('bareJid'));
                jQuery(this).parent().parent().parent().hide();
            })));
            var chatBoxSubTop = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.SUBTOP).append(ChatBar.UI.Utils.getTruncatedContactStatus(contactBareJid));
            var chatBoxContent = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.CONTENT).attr('bareJid', contactBareJid);
            var chatBoxInput = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.INPUT).append(jQuery('<textarea></textarea>').attr('bareJid', contactBareJid).bind('keypress', ChatBar.UI.ChatBoxes.onTypingMessage).bind('keyup', function(e) {
                if ((e.keyCode ? e.keyCode : e.which) == 13)
                    jQuery(this).val('');
            }));
            var chatBoxBottom = jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.BOTTOM).append(jQuery('<span></span>').append(jQuery('<span></span>')));
            chatBox.append(chatBoxTop).append(chatBoxSubTop).append(chatBoxContent).append(chatBoxInput).append(chatBoxBottom).appendTo(chatBoxes);
        }
    },
    takeStand: function(contactBareJid) {
        var chatBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES).children();
        var chatBoxElm = chatBoxesElm.filter("[bareJid^='" + contactBareJid + "']");
        var chatBoxContentElm = chatBoxElm.children().filter("[bareJid^='" + contactBareJid + "']");
        var scrollBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES);
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid);
        if (!chatBoxElm.is(':hidden')) {
            ChatBar.UI.ScrollBoxes.unselect(contactBareJid);
            chatBoxElm.hide();
        } else {
            jQuery.each(chatBoxesElm.filter("[bareJid!='" + contactBareJid + "']"), function() {
                ChatBar.UI.ScrollBoxes.unselect(jQuery(this).attr('bareJid'));
                jQuery(this).hide();
            });
            ChatBar.UI.ScrollBoxes.select(contactBareJid);
            ChatBar.UI.UnreadCountBox.remove(contactBareJid);
            var pos = scrollBoxElm.position().left - (chatBoxElm.width() - scrollBoxElm.width()) + 24;
            chatBoxElm.show().css({
                'left': pos
            });
            chatBoxContentElm.scrollTo('max');
            chatBoxElm.children().filter('[class=' + ChatBar.UI.Resources.StyleClasses.ChatBox.INPUT + ']').find('textarea').focus();
        }
    },
    onTypingMessage: function(e) {
        var keyCode = (e.keyCode) ? e.keyCode : e.which;
        var contactBareJid = jQuery(this).attr('bareJid');
        if (keyCode == 13 && jQuery(this).val() != '') {
            g_cb_user.sendChatMessage(contactBareJid, jQuery.trim(jQuery(this).val()));
            ChatBar.UI.ChatBoxes.update(contactBareJid, ChatBar.UI.Utils.truncateString(ChatBar.UI.Resources.Strings.ChatMessages.SELF, 24), jQuery(this).val(), false);
            clearTimeout(ChatBar.UI.ChatBoxes.lastTimedPauses[contactBareJid]);
            ChatBar.UI.ChatBoxes.lastTimedPauses[contactBareJid] = null;
        } else {
            var nowTime = new Date().getTime();
            if (ChatBar.UI.ChatBoxes.dateLastComposing[contactBareJid] == null || ChatBar.UI.ChatBoxes.dateLastComposing[contactBareJid] + 2000 < nowTime) {
                ChatBar.UI.ChatBoxes.dateLastComposing[contactBareJid] = nowTime;
                g_cb_user.sendChatStateMessage(contactBareJid, ChatBar.Message.ChatStates.COMPOSING);
            }
            clearTimeout(ChatBar.UI.ChatBoxes.lastTimedPauses[contactBareJid]);
            ChatBar.UI.ChatBoxes.lastTimedPauses[contactBareJid] = setTimeout('g_cb_user.sendChatStateMessage(\'' + contactBareJid + '\', ChatBar.Message.ChatStates.PAUSED)', 2000);
            var chatBoxTextAreaElm = ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid).children().filter('[class=' + ChatBar.UI.Resources.StyleClasses.ChatBox.INPUT + ']').find('textarea');
            chatBoxTextAreaElm.scrollTo('max');
        }
    },
    update: function(contactBareJid, fromName, msg, delayDate) {
        var chatBoxElm = ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid);
        if (chatBoxElm.length == 0) {
            if ((g_cb_roster_items != null && g_cb_roster_items[contactBareJid]) || (g_cb_userinfos != null && g_cb_userinfos[contactBareJid])) {
                ChatBar.UI.ScrollBoxes.add(contactBareJid);
                chatBoxElm = ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid);
                ChatBar.UI.ChatBoxes.doUpdate(chatBoxElm, contactBareJid, fromName, msg, delayDate);
            } else {
                return false;
            }
        } else {
            ChatBar.UI.ChatBoxes.doUpdate(chatBoxElm, contactBareJid, fromName, msg, delayDate);
        }
    },
    doUpdate: function(chatBoxElm, contactBareJid, fromName, msg, delayDate) {
        var chatBoxContentElm = chatBoxElm.children().filter("[bareJid^='" + contactBareJid + "']");
        chatBoxContentElm.find('p').filter("[class^='" + ChatBar.UI.Resources.StyleClasses.ChatBox.STATE + "']").remove();
        var chatBoxLastMessageElm = jQuery(chatBoxContentElm).find('div').filter("[class^='" + ChatBar.UI.Resources.StyleClasses.ChatBox.MESSAGE + "']").filter(':last');
        if (chatBoxLastMessageElm && chatBoxLastMessageElm.find('span').filter("[class^='" + ChatBar.UI.Resources.StyleClasses.ChatBox.MESSAGE_SENDER + "']").text() == fromName) {
            chatBoxLastMessageElm.append('<p>' + ChatBar.UI.Utils.getPrintableChatMessage(msg) + '</p>');
        } else {
            if (typeof delayDate === 'undefined' || !delayDate || !ChatBar.UI.Utils.isValidDate(delayDate)) {
                var dateTime = ChatBar.UI.Utils.getNowFormattedTime();
            } else {
                var dateTime = ChatBar.UI.Utils.getFormattedDateTime(delayDate);
            }
            chatBoxContentElm.append(jQuery('<div></div>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.MESSAGE).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.MESSAGE_SENDER).text(fromName)).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.MESSAGE_DATE).text(dateTime)).append('<p>' + ChatBar.UI.Utils.getPrintableChatMessage(msg) + '</p>'));
        }
        chatBoxContentElm.scrollTo('max');
        var scrollBoxesElm = jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_SCROLLBOXES);
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid);
        if (ChatBar.UI.ScrollBoxes.isInitialized == false) {
            scrollBoxesElm.trigger('goto', scrollBoxesElm.find('ul').children().index(scrollBoxElm));
        }
        if (chatBoxElm.is(':hidden')) {
            ChatBar.UI.UnreadCountBox.update(contactBareJid);
            if (ChatBar.UI.HAS_FOCUS)
                DHTMLSound();
        }
        if (!ChatBar.UI.HAS_FOCUS)
            DHTMLSound();
    },
    updateChatState: function(contactBareJid, msg) {
        var chatBoxContentElm = ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid).children().filter("[bareJid^='" + contactBareJid + "']");
        jQuery(msg).children().each(function() {
            if (this.tagName == ChatBar.Message.ChatStates.COMPOSING) {
                if (chatBoxContentElm.find('p').filter('[class=' + ChatBar.UI.Resources.StyleClasses.ChatBox.STATE + ']').length == 0) {
                    jQuery('<p></p>').attr('class', ChatBar.UI.Resources.StyleClasses.ChatBox.STATE).html(ChatBar.UI.Utils.getContactName(contactBareJid) + ChatBar.UI.Resources.Strings.ChatMessages.COMPOSING + "</br />").appendTo(chatBoxContentElm);
                }
            } else if (this.tagName == ChatBar.Message.ChatStates.PAUSED) {
                chatBoxContentElm.find('p').filter('[class=' + ChatBar.UI.Resources.StyleClasses.ChatBox.STATE + ']').remove();
            }
        });
        chatBoxContentElm.scrollTo('max');
    },
    remove: function(contactBareJid) {
        ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid).remove();
        ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid).remove();
    },
    show: function(contactBareJid) {
        ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid).show();
    },
    hide: function(contactBareJid) {
        ChatBar.UI.ChatBoxes.getChatBoxElm(contactBareJid).hide();
    },
    getChatBoxElm: function(contactBareJid) {
        return jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES).children().filter("[bareJid^='" + contactBareJid + "']");
    }
};
ChatBar.UI.UnreadCountBox = {
    add: function(contactBareJid) {
        ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid).append(jQuery('<span></span>').attr('class', ChatBar.UI.Resources.StyleClasses.UNREAD_COUNT));
    },
    remove: function(contactBareJid) {
        ChatBar.UI.UnreadCountBox.getElm(contactBareJid).remove();
    },
    update: function(contactBareJid) {
        if (arguments.length > 1 && !arguments[1])
            return;
        var unreadCountBoxElm = ChatBar.UI.UnreadCountBox.getElm(contactBareJid);
        if (unreadCountBoxElm.length == 0) {
            ChatBar.UI.UnreadCountBox.add(contactBareJid);
            unreadCountBoxElm = ChatBar.UI.UnreadCountBox.getElm(contactBareJid);
        }
        if (arguments.length == 1) {
            var unreadCount = unreadCountBoxElm.text();
            unreadCountBoxElm.text(++unreadCount);
        } else
            unreadCountBoxElm.text(arguments[1]);
    },
    getElm: function(contactBareJid) {
        return ChatBar.UI.ScrollBoxes.getScrollBoxElm(contactBareJid).find('span').filter('[class=' + ChatBar.UI.Resources.StyleClasses.UNREAD_COUNT + ' ]');
    }
};
ChatBar.UI.Utils = {
    getTruncatedContactName: function(bareJid) {
        return (ChatBar.UI.Utils.truncateString(ChatBar.UI.Utils.getContactName(bareJid), (arguments.length == 2) ? arguments[1] : 21));
    },
    getTruncatedContactStatus: function(bareJid) {
        return (ChatBar.UI.Utils.truncateString(ChatBar.UI.Utils.getContactStatus(bareJid), (arguments.length == 2 ? arguments[1] : 50)));
    },
    getContactName: function(bareJid) {
        var contactName = '';
        if (g_cb_userinfos != null && g_cb_userinfos[bareJid])
            contactName = g_cb_userinfos[bareJid].name;
        if ((!contactName || contactName == '') && (g_cb_roster_items != null && g_cb_roster_items[bareJid]))
            contactName = g_cb_roster_items[bareJid].name;
        if (!contactName || contactName == '') {
            contactName = bareJid;
            var getFailed = true;
        }
        if (getFailed || contactName.indexOf('@') >= 0) {
            var parts = contactName.split('@');
            contactName = parts[0];
        }
        return (contactName);
    },
    getContactIcon: function(bareJid) {
        var contactIcon = '';
        if (g_cb_roster_items != null && g_cb_roster_items[bareJid])
            contactIcon = g_cb_roster_items[bareJid].icon_tiny;
        if ((!contactIcon || contactIcon == '') && (g_cb_userinfos != null && g_cb_userinfos[bareJid]))
            contactIcon = ChatBar.UI.Utils.getStaticURL(g_cb_userinfos[bareJid].icon_tiny);
        if (!contactIcon || contactIcon == '')
            contactIcon = '/templates/core/images/no_pic_mini_m.jpg';
        return (contactIcon);
    },
    getContactStatus: function(bareJid) {
        var contactStatus = '';
        if (g_cb_roster_items != null && g_cb_roster_items[bareJid])
            contactStatus = g_cb_roster_items[bareJid].status;
        if ((!contactStatus || contactStatus == '') && (g_cb_userinfos != null && g_cb_userinfos[bareJid]))
            contactStatus = g_cb_userinfos[bareJid].status;
        if (!contactStatus || contactStatus == '')
            contactStatus = '';
        return (contactStatus);
    },
    getPrintableChatMessage: function(msg) {
        var val = new String;
        val = jQuery('<div>' + msg + '</div>');
        msg = val.text();
        msg = jQuery.trim(msg);
        msg = ChatBar.UI.Utils.replaceLinks(msg);
        msg = ChatBar.UI.Utils.replaceSmileys(msg);
        return msg;
    },
    parseISO8601: function(date) {
        var origParse = Date.parse,
            numericKeys = [1, 4, 5, 6, 7, 10, 11];
        var timestamp, struct, minutesOffset = 0;
        if ((struct = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(date))) {
            for (var i = 0, k;
                (k = numericKeys[i]); ++i) {
                struct[k] = +struct[k] || 0;
            }
            struct[2] = (+struct[2] || 1) - 1;
            struct[3] = +struct[3] || 1;
            if (struct[8] !== 'Z' && struct[9] !== undefined) {
                minutesOffset = struct[10] * 60 + struct[11];
                if (struct[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }
            timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
        } else {
            timestamp = origParse ? origParse(date) : NaN;
        }
        return timestamp;
    },
    isValidDate: function(d) {
        if (Object.prototype.toString.call(d) !== "[object Date]")
            return false;
        return !isNaN(d.getTime());
    },
    getNowFormattedTime: function() {
        var date = new Date();
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        if (hours < 10)
            hours = '0' + hours;
        if (minutes < 10)
            minutes = '0' + minutes;
        if (seconds < 10)
            seconds = '0' + seconds;
        return (hours + ':' + minutes + ':' + seconds);
    },
    getFormattedDateTime: function(date) {
        var day = date.getDate();
        var month = date.getMonth() + 1;
        var year = date.getFullYear();
        var hours = date.getHours();
        var minutes = date.getMinutes();
        if (hours < 10)
            hours = '0' + hours;
        if (minutes < 10)
            minutes = '0' + minutes;
        if (day < 10)
            day = '0' + day;
        if (month < 10)
            month = '0' + month;
        return (day + '.' + month + '.' + year + ' ' + hours + ':' + minutes);
    },
    getStaticURL: function(str) {
        if (str.indexOf('//') != 0 && str.indexOf('http://') < 0 && str.indexOf('https://') < 0) {
            str = g_url_static + str;
        }
        return str;
    },
    replaceSmileys: function(str) {
        if (typeof cb_smileySearch === 'undefined' || !cb_smileySearch || cb_smileySearch.length < 1) {
            return str;
        }
        for (var i = 0; i < cb_smileySearch.length; i++) {
            str = str.replace(cb_smileySearch[i], '<img src="' + cb_smileyReplace[i] + '" alt="" border="0" />');
        }
        return str;
    },
    replaceLinks: function(str) {
        var xpr = /((ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?)/gi;
        return (str.replace(xpr, '<a href="$1" target="_blank">$1</a>'));
    },
    truncateString: function(str, len) {
        if (str != null && str.length > len)
            return ((str.substr(0, len) + '...'));
        return (str);
    },
    startChat: function(contactBareJid) {
        if (!g_cb_is_connected) {
            ChatBar.UI.connect();
            g_cb_startchat = contactBareJid;
            return;
        }
        if ((g_cb_roster_items != null && g_cb_roster_items[contactBareJid]) || (g_cb_userinfos != null && g_cb_userinfos[contactBareJid])) {
            ChatBar.UI.ScrollBoxes.add(contactBareJid, true);
            g_cb_startchat = null;
        } else {
            jQuery.ajax({
                type: 'POST',
                url: ChatBar.UI.addActionTokens('/chatbar/get_userinfos.do'),
                async: true,
                cache: false,
                data: {
                    'jid': contactBareJid
                },
                dataType: 'json',
                success: function(json) {
                    if (g_cb_userinfos == null) {
                        g_cb_userinfos = new Object();
                    }
                    g_cb_userinfos[contactBareJid] = json;
                    ChatBar.UI.ScrollBoxes.add(contactBareJid, true);
                    g_cb_startchat = null;
                }
            });
        }
    }
};

function init_cb(ts, token) {
    if (typeof document.body.style.maxHeight === "undefined") {
        return;
    }
    if (!g_cb_userinfos) {
        window.setTimeout("init_cb('" + ts + "', '" + token + "')", 1500);
        return;
    }
    ChatBar.UI.initialize(ts, token);
}

function DHTMLSound() {
    if (!g_cb_play_sound) {
        return false;
    }
    document.getElementById("cbpock").innerHTML = '<embed src="/templates/core/images/chatbar/newmessage.wav" hidden="true" autostart="true" loop="false" width="1" height="1" />';
}

function cb_debug(msg) {
    return;
    jQuery('#cb_debug').append('<p>' + msg + '</p>');
}
jQuery(window).resize(function() {
    if (typeof document.body.style.maxHeight === "undefined") {
        return;
    }
    jQuery('#' + ChatBar.UI.Resources.Elements.ID_DIV_CHATBOXES).children().each(function() {
        var scrollBoxElm = ChatBar.UI.ScrollBoxes.getScrollBoxElm(jQuery(this).attr('bareJid'));
        var pos = scrollBoxElm.position().left - (jQuery(this).width() - scrollBoxElm.width()) + 24;
        jQuery(this).css({
            'left': pos
        });
    });
});
jQuery(window).unload(function() {
    if (typeof document.body.style.maxHeight === "undefined") {
        return;
    }
    if (!jQuery('#cb').length)
        return;
    if (g_cb_user != null) {
        g_cb_user.requestSessionPause();
        ChatBar.UI.saveState();
    }
    ChatBar.UI.saveConnection();
});
jQuery(window).bind('blur', function() {
    ChatBar.UI.HAS_FOCUS = false;
});
jQuery(window).bind('focus', function() {
    ChatBar.UI.HAS_FOCUS = true;
});